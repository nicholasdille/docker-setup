tools:

  - name: arkade
    version: 0.8.30
    check: ${binary} version | grep "version" | cut -d' ' -f2
    tags:
    - k8s
    - kubernetes
    - package
    - management
    download:
    - url:
        x86_64: https://github.com/alexellis/arkade/releases/download/${version}/arkade
        aarch64: https://github.com/alexellis/arkade/releases/download/${version}/arkade-arm64
      type: executable
    post_install: |
      ${binary} completion bash >"${target}/share/bash-completion/completions/ytt"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/ytt.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_ytt"

  - name: buildah
    version: 1.26.4
    check: ${binary} --version | cut -d' ' -f3
    needs:
    - runc
    - cni
    tags:
    - build
    - redhat
    - oci
    download:
    - url:
        x86_64: https://github.com/nicholasdille/buildah-static/releases/download/v${version}/buildah.tar.gz
      type: tarball
      path: ${target}

  - name: buildkit
    version: 0.10.3
    binary: buildkitd
    tags:
    - docker
    - build
    - oci
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    download:
    - url: https://github.com/moby/buildkit/releases/download/v${version}/buildkit-v${version}.linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      strip: 1
    - url: https://github.com/moby/buildkit/raw/v${version}/examples/systemd/buildkit.service
      type: file
      path: ${prefix}/etc/systemd/system/buildkit.service
    - url: https://github.com/moby/buildkit/raw/v${version}/examples/systemd/buildkit.socket
      type: file
      path: ${prefix}/etc/systemd/system/buildkit.socket
    files:
    - path: ${prefix}/etc/init.d/buildkit
      content: |
        #!/bin/sh
        set -e

        ### BEGIN INIT INFO
        # Provides:           buildkit
        # Required-Start:     $syslog $remote_fs
        # Required-Stop:      $syslog $remote_fs
        # Should-Start:       cgroupfs-mount cgroup-lite
        # Should-Stop:        cgroupfs-mount cgroup-lite
        # Default-Start:      2 3 4 5
        # Default-Stop:       0 1 6
        # Short-Description:  Create lightweight, portable, self-sufficient containers.
        # Description:
        #  Docker is an open-source project to easily create lightweight, portable,
        #  self-sufficient containers from any application. The same container that a
        #  developer builds and tests on a laptop can run at scale, in production, on
        #  VMs, bare metal, OpenStack clusters, public clouds and more.
        ### END INIT INFO

        export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin

        BASE=buildkit

        # modify these in /etc/default/$BASE (/etc/default/buildkit)
        BUILDKIT=/usr/local/bin/buildkitd
        # This is the pid file created/managed by start-stop-daemon
        BUILDKIT_SSD_PIDFILE=/var/run/$BASE-ssd.pid
        BUILDKIT_LOGFILE=/var/log/$BASE.log
        BUILDKIT_DESC="BuildKit"

        # Get lsb functions
        . /lib/lsb/init-functions

        if [ -f /etc/default/$BASE ]; then
          . /etc/default/$BASE
        fi

        # Check buildkit is present
        if [ ! -x $BUILDKIT ]; then
          log_failure_msg "$BUILDKIT not present or not executable"
          exit 1
        fi

        check_init() {
          # see also init_is_upstart in /lib/lsb/init-functions (which isn't available in Ubuntu 12.04, or we'd use it directly)
          if [ -x /sbin/initctl ] && /sbin/initctl version 2> /dev/null | grep -q upstart; then
            log_failure_msg "$BUILDKIT_DESC is managed via upstart, try using service $BASE $1"
            exit 1
          fi
        }

        fail_unless_root() {
          if [ "$(id -u)" != '0' ]; then
            log_failure_msg "$BUILDKIT_DESC must be run as root"
            exit 1
          fi
        }

        cgroupfs_mount() {
          # see also https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount
          if grep -v '^#' /etc/fstab | grep -q cgroup \
            || [ ! -e /proc/cgroups ] \
            || [ ! -d /sys/fs/cgroup ]; then
            return
          fi
          if ! mountpoint -q /sys/fs/cgroup; then
            mount -t tmpfs -o uid=0,gid=0,mode=0755 cgroup /sys/fs/cgroup
          fi
          (
            cd /sys/fs/cgroup
            for sys in $(awk '!/^#/ { if ($4 == 1) print $1 }' /proc/cgroups); do
              mkdir -p $sys
              if ! mountpoint -q $sys; then
                if ! mount -n -t cgroup -o $sys cgroup $sys; then
                  rmdir $sys || true
                fi
              fi
            done
          )
        }

        case "$1" in
          start)
            check_init

            fail_unless_root

            cgroupfs_mount

            touch "$BUILDKIT_LOGFILE"

            ulimit -n 1048576

            # Having non-zero limits causes performance problems due to accounting overhead
            # in the kernel. We recommend using cgroups to do container-local accounting.
            if [ "$BASH" ]; then
              ulimit -u unlimited
            else
              ulimit -p unlimited
            fi

            log_begin_msg "Starting $BUILDKIT_DESC: $BASE"
            start-stop-daemon --start --background \
              --no-close \
              --exec "$BUILDKIT" \
              --pidfile "$BUILDKIT_SSD_PIDFILE" \
              --make-pidfile \
              -- \
              >> "$BUILDKIT_LOGFILE" 2>&1
            log_end_msg $?
            ;;

          stop)
            check_init
            fail_unless_root
            if [ -f "$BUILDKIT_SSD_PIDFILE" ]; then
              log_begin_msg "Stopping $BUILDKIT_DESC: $BASE"
              start-stop-daemon --stop --pidfile "$BUILDKIT_SSD_PIDFILE" --retry 10
              log_end_msg $?
            else
              log_warning_msg "Docker already stopped - file $BUILDKIT_SSD_PIDFILE not found."
            fi
            ;;

          restart)
            check_init
            fail_unless_root
            buildkit_pid=$(cat "$BUILDKIT_SSD_PIDFILE" 2> /dev/null)
            [ -n "$buildkit_pid" ] \
              && ps -p $buildkit_pid > /dev/null 2>&1 \
              && $0 stop
            $0 start
            ;;

          force-reload)
            check_init
            fail_unless_root
            $0 restart
            ;;

          status)
            check_init
            status_of_proc -p "$BUILDKIT_SSD_PIDFILE" "$BUILDKIT" "$BUILDKIT_DESC"
            ;;

          *)
            echo "Usage: service buildkit {start|stop|restart|status}"
            exit 1
            ;;
        esac
    post_install: |
      echo "Install systemd units"
      sed -i "s|ExecStart=/usr/local/bin/buildkitd|ExecStart=${target}/bin/buildkitd|" "${prefix}/etc/systemd/system/buildkit.service"
      echo "Install init script"
      sed -i "s|/usr/local/bin/buildkitd|${relative_target}/bin/buildkitd|" "${prefix}/etc/init.d/buildkit"
      chmod +x "${prefix}/etc/init.d/buildkit"
      if test -z "${prefix}" && has_systemd; then
          echo "Reload systemd"
          systemctl daemon-reload
      fi

  - name: buildx
    version: 0.8.2
    binary: ${target}/libexec/docker/cli-plugins/docker-buildx
    check: ${binary} version | cut -d' ' -f2 | tr -d v
    needs:
    - docker
    tags:
    - default
    - docker
    - plugin
    download:
    - url: https://github.com/docker/buildx/releases/download/v${version}/buildx-v${version}.linux-${alt_arch}
      type: executable
    post_install: |
      if test -z "${prefix}"; then
          echo "Set buildx as the default builder"
          docker buildx install
      fi
      if docker_is_running || tool_will_be_installed "docker"; then
          echo "Wait for Docker daemon to start"
          wait_for_docker
          echo "Enable multi-platform builds"
          "${target}/bin/docker" container run --privileged --rm tonistiigi/binfmt --install all
      fi
  
  - name: bypass4netns
    version: 0.2.2
    needs:
    - docker
    - slirp4netns
    tags:
    - rootless
    - network
    dockerfile: |
      FROM golang:${go_version}
      RUN apt-get update \
       && apt-get -y install \
              libseccomp-dev
    install: |
      docker_run \
          --workdir /go/src/github.com/rootless-containers/bypass4netns \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/rootless-containers/bypass4netns .
      make static
      cp bypass4netns{,d} /target/bin/
      EOF

  - name: cinf
    version: 0.6.0
    tags:
    - kernel
    - cgroups
    - caps
    download:
    - url: https://github.com/mhausenblas/cinf/releases/download/v${version}/cinf_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - cinf

  - name: clusterawsadm
    version: 1.4.1
    check: ${binary} version --output short | tr -d v
    tags:
    - k8s
    - kubernetes
    - cloud
    download:
    - url: https://github.com/kubernetes-sigs/cluster-api-provider-aws/releases/download/v${version}/clusterawsadm-linux-amd64
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/clusterawsadm"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/clusterawsadm.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_clusterawsadm"

  - name: clusterctl
    version: 1.2.0
    check: ${binary} version --output short | tr -d v
    tags:
    - k8s
    - kubernetes
    download:
    - url: https://github.com/kubernetes-sigs/cluster-api/releases/download/v${version}/clusterctl-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/clusterctl"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_clusterctl"

  - name: cni
    version: 1.1.1
    binary: ${target}/libexec/cni/loopback
    check: ${binary} 2>&1 | cut -d' ' -f4 | tr -d v
    tags:
    - k8s
    - kubernetes
    - network
    download:
    - url: https://github.com/containernetworking/plugins/releases/download/v${version}/cni-plugins-linux-${alt_arch}-v${version}.tgz
      type: tarball
      path: ${target}/libexec/cni

  - name: cnitool
    version: 1.1.2
    needs:
    - docker
    tags:
    - k8s
    - kubernetes
    - network
    dockerfile: |
      FROM golang:${go_version}
    install: |
      docker_run \
          --workdir /go/src/github.com/containernetworking/cni \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/containernetworking/cni .
      cd cnitool
      CGO_ENABLED=0 go build -ldflags '-s -w' -o cnitool .
      cp cnitool /target/bin/
      EOF

  - name: cni-isolation
    version: 0.0.4
    binary: ${target}/libexec/cni/isolation
    tags:
    - k8s
    - kubernetes
    - network
    download:
    - url: https://github.com/AkihiroSuda/cni-isolation/releases/download/v${version}/cni-isolation-${alt_arch}.tgz
      type: tarball
      path: ${target}/libexec/cni

  - name: conmon
    version: 2.1.3
    check: ${binary} --version | grep "conmon version" | cut -d' ' -f3
    tags:
    - redhat
    - runtime
    download:
    - url: https://github.com/nicholasdille/conmon-static/releases/download/v${version}/conmon-${alt_arch}.tar.gz
      type: tarball
      path: ${target}
    - url: https://github.com/containers/podman/raw/v${version}/contrib/systemd/system/podman.service
      type: file
      path: ${prefix}/etc/systemd/system/podman.service
    - url: https://github.com/containers/podman/raw/v${version}/contrib/systemd/system/podman.socket
      type: file
      path: ${prefix}/etc/systemd/system/podman.socket
    - url: https://github.com/containers/podman/raw/v${version}/contrib/systemd/system/podman-docker.conf
      type: file
      path: ${target}/lib/tmpfiles.d/podman-docker.conf
    files:
    - path: ${prefix}/etc/containers/registries.conf.d/00-shortnames.conf
      content: |
        [aliases]
          "almalinux" = "docker.io/library/almalinux"
          "almalinux-minimal" = "docker.io/library/almalinux-minimal"
          "centos" = "quay.io/centos/centos"
          "skopeo" = "quay.io/skopeo/stable"
          "buildah" = "quay.io/buildah/stable"
          "podman" = "quay.io/podman/stable"
          "alpine" = "docker.io/library/alpine"
          "docker" = "docker.io/library/docker"
          "registry" = "docker.io/library/registry"
          "hello-world" = "docker.io/library/hello-world"
          "swarm" = "docker.io/library/swarm"
          "fedora-minimal" = "registry.fedoraproject.org/fedora-minimal"
          "fedora" = "registry.fedoraproject.org/fedora"
          "opensuse/tumbleweed" = "registry.opensuse.org/opensuse/tumbleweed"
          "opensuse/tumbleweed-dnf" = "registry.opensuse.org/opensuse/tumbleweed-dnf"
          "opensuse/tumbleweed-microdnf" = "registry.opensuse.org/opensuse/tumbleweed-microdnf"
          "opensuse/leap" = "registry.opensuse.org/opensuse/leap"
          "opensuse/busybox" = "registry.opensuse.org/opensuse/busybox"
          "tumbleweed" = "registry.opensuse.org/opensuse/tumbleweed"
          "tumbleweed-dnf" = "registry.opensuse.org/opensuse/tumbleweed-dnf"
          "tumbleweed-microdnf" = "registry.opensuse.org/opensuse/tumbleweed-microdnf"
          "leap" = "registry.opensuse.org/opensuse/leap"
          "leap-dnf" = "registry.opensuse.org/opensuse/leap-dnf"
          "leap-microdnf" = "registry.opensuse.org/opensuse/leap-microdnf"
          "tw-busybox" = "registry.opensuse.org/opensuse/busybox"
          "suse/sle15" = "registry.suse.com/suse/sle15"
          "suse/sles12sp5" = "registry.suse.com/suse/sles12sp5"
          "suse/sles12sp4" = "registry.suse.com/suse/sles12sp4"
          "suse/sles12sp3" = "registry.suse.com/suse/sles12sp3"
          "sle15" = "registry.suse.com/suse/sle15"
          "sles12sp5" = "registry.suse.com/suse/sles12sp5"
          "sles12sp4" = "registry.suse.com/suse/sles12sp4"
          "sles12sp3" = "registry.suse.com/suse/sles12sp3"
          "rhel" = "registry.access.redhat.com/rhel"
          "rhel6" = "registry.access.redhat.com/rhel6"
          "rhel7" = "registry.access.redhat.com/rhel7"
          "ubi7" = "registry.access.redhat.com/ubi7"
          "ubi7-init" = "registry.access.redhat.com/ubi7-init"
          "ubi7-minimal" = "registry.access.redhat.com/ubi7-minimal"
          "ubi8" = "registry.access.redhat.com/ubi8"
          "ubi8-minimal" = "registry.access.redhat.com/ubi8-minimal"
          "ubi8-init" = "registry.access.redhat.com/ubi8-init"
          "ubi8-micro" = "registry.access.redhat.com/ubi8-micro"
          "ubi8/ubi" = "registry.access.redhat.com/ubi8/ubi"
          "ubi8/ubi-minimal" = "registry.access.redhat.com/ubi8-minimal"
          "ubi8/ubi-init" = "registry.access.redhat.com/ubi8-init"
          "ubi8/ubi-micro" = "registry.access.redhat.com/ubi8-micro"
          "debian" = "docker.io/library/debian"
          "ubuntu" = "docker.io/library/ubuntu"
          "oraclelinux" = "container-registry.oracle.com/os/oraclelinux"
          "busybox" = "docker.io/library/busybox"
          "php" = "docker.io/library/php"
          "python" = "docker.io/library/python"
          "node" = "docker.io/library/node"
    - path: ${prefix}/etc/containers/registries.d/default.yaml
      content: |
        default-docker:
          sigstore-staging: file:///var/lib/containers/sigstore
    - path: ${prefix}/etc/containers/policy.json
      content: |
        {
          "default": [
            {
              "type": "insecureAcceptAnything"
            }
          ],
          "transports": {
            "docker-daemon": {
              "": [
                {
                  "type":"insecureAcceptAnything"
                }
              ]
            }
          }
        }
    - path: ${prefix}/etc/containers/registries.json
      content: |
        unqualified-search-registries = ["docker.io", "quay.io"]
    - path: ${prefix}/etc/containers/storage.conf
      content: |
        [storage]
        driver = "overlay"
        runroot = "/run/containers/storage"
        graphroot = "/var/lib/containers/storage"

        [storage.options]
        additionalimagestores = [
        ]

        [storage.options.overlay]
        mountopt = "nodev,metacopy=on"

        [storage.options.thinpool]
    post_install: |
      echo "Fix systemd unit"
      sed -i "s|ExecStart=/usr/bin/podman|ExecStart=${relative_target}/bin/podman|" "${prefix}/etc/systemd/system/podman.service"
      if test -z "${prefix}"; then
          if has_systemd; then
              systemctl daemon-reload
          fi
      fi

  - name: containerd
    version: 1.6.7
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    needs:
    - runc
    - cni
    - dasel
    tags:
    - runtime
    - containerd
    download:
    - url: https://github.com/containerd/containerd/releases/download/v${version}/containerd-${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}
    - url: https://github.com/containerd/containerd/raw/v${version}/containerd.service
      type: file
      path: ${prefix}/etc/systemd/system/containerd.service
    dockerfile: |
      FROM golang:${go_version}
    post_install: |
      if ${skip_docs}; then
          warning "Installation of manpages will be skipped."

      else
          docker_run \
              --workdir /go/src/github.com/containerd/containerd \
              <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/containerd/containerd .
      go install github.com/cpuguy83/go-md2man@latest
      export GO111MODULE=auto
      make man
      cp -r man/*.5 "/opt/man/man5"
      cp -r man/*.8 "/opt/man/man8"
      EOF
      fi
      if ! test -f "${prefix}/etc/containerd/config.toml"; then
          echo "Adding default configuration"
          mkdir -p "${prefix}/etc/containerd"
          "${target}/bin/containerd" config default >"${prefix}/etc/containerd/config.toml"
          sed -i "s|/opt/cni/bin|${relative_target}/libexec/cni|" "${prefix}/etc/containerd/config.toml"
      fi
      echo "Install systemd unit"
      sed -i "s|ExecStart=/usr/local/bin/containerd|ExecStart=${relative_target}/bin/containerd|" "${prefix}/etc/systemd/system/containerd.service"
      if test -z "${prefix}"; then
          if has_systemd; then
              echo "Reload systemd"
              systemctl daemon-reload
          else
              warning "docker-setup does not offer an init script for containerd."
          fi
      fi

  - name: containerssh
    version: 0.4.1
    tags:
    - security
    download:
    - url: https://github.com/ContainerSSH/ContainerSSH/releases/download/v${version}/containerssh_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - containerssh
      - containerssh-auditlog-decoder
      - containerssh-testauthconfigserver

  - name: cosign
    version: 1.10.1
    check: ${binary} version | grep GitVersion | tr -s ' ' | cut -d' ' -f2 | tr -d v
    needs:
    - docker
    tags:
    - security
    download:
    - url: https://github.com/sigstore/cosign/releases/download/v${version}/cosign-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/cosign"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/cosign.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_cosign"

  - name: crane
    version: 0.11.0
    check: ${binary} version
    tags:
    - registry
    - image
    - oci
    download:
    - url: https://github.com/google/go-containerregistry/releases/download/v${version}/go-containerregistry_Linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - crane
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/crane"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/crane.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_crane"

  - name: cri-dockerd
    version: 0.2.5
    check: ${binary} --version 2>&1 | cut -d' ' -f2
    tags:
    - docker
    - k8s
    - kubernetes
    - runtime
    download:
    - url: https://github.com/Mirantis/cri-dockerd/releases/download/v${version}/cri-dockerd-v${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - cri-dockerd

  - name: crictl
    version: 1.24.2
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    tags:
    - k8s
    - kubernetes
    - runtime
    download:
    - url: https://github.com/kubernetes-sigs/cri-tools/releases/download/v${version}/crictl-v${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin

  - name: crun
    version: 1.5
    check: ${binary} --version | grep "crun version" | cut -d' ' -f3
    needs:
    - docker
    tags:
    - runtime
    - redhat
    - oci
    download:
    - url:
        x86_64: https://github.com/nicholasdille/crun-static/releases/download/v${version}/crun.tar.gz
      type: tarball
      path: ${target}
    post_install: |
      if ! test -f "${prefix}/etc/docker/daemon.json" || ! test "$(jq --raw-output '.runtimes | keys | any(. == "crun")' "${prefix}/etc/docker/daemon.json")" == "true"; then
          echo "Add runtime to Docker"
          # shellcheck disable=SC2094
          cat >"${docker_setup_cache}/daemon.json-crun.sh" <<EOF
      cat <<< "\$(jq --arg target "${target}" '. * {"runtimes":{"crun":{"path":"\(\$target)/bin/crun"}}}' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
      EOF
          touch "${docker_setup_cache}/docker_restart"
      fi

  - name: ctop
    version: 0.7.7
    check: ${binary} -v | cut -d, -f1 | cut -d' ' -f3
    tags:
    - analysis
    - management
    - tui
    needs:
    - docker
    download:
    - url: https://github.com/bcicen/ctop/releases/download/${version}/ctop-${version}-linux-${alt_arch}
      type: executable

  - name: cyclonedx-cli
    version: 0.24.0
    tags:
    - security
    - sbom
    download:
    - url:
        x86_64: https://github.com/CycloneDX/cyclonedx-cli/releases/download/v${version}/cyclonedx-linux-x64
        aarch64: https://github.com/CycloneDX/cyclonedx-cli/releases/download/v${version}/cyclonedx-linux-arm64
      type: executable

  - name: dagger
    version: 0.2.28
    check: ${binary} version | cut -d' ' -f2
    tags:
    - management
    download:
    - url: https://github.com/dagger/dagger/releases/download/v${version}/dagger_v${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - dagger

  - name: dasel
    version: 1.26.0
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    tags:
    - conversion
    - format
    download:
    - url: https://github.com/TomWright/dasel/releases/download/v${version}/dasel_linux_${alt_arch}
      type: executable

  - name: dive
    version: 0.10.0
    check: ${binary} --version | cut -d' ' -f2
    needs:
    - docker
    tags:
    - analysis
    - build
    - tui
    download:
    - url: https://github.com/wagoodman/dive/releases/download/v${version}/dive_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - dive

  - name: docker
    version: 20.10.17
    binary: dockerd
    check: ${binary} --version | cut -d, -f1 | cut -d' ' -f3
    needs:
    - iptables
    - fuse-overlayfs
    tags:
    - default
    - docker
    - runtime
    - build
    - oci
    download:
    - url: https://download.docker.com/linux/static/stable/${arch}/docker-${version}.tgz
      type: tarball
      strip: 1
      path: ${target}/libexec/docker/bin
    - url: https://download.docker.com/linux/static/stable/${arch}/docker-rootless-extras-${version}.tgz
      type: tarball
      strip: 1
      path: ${target}/libexec/docker/bin
    - url: https://github.com/docker/cli/raw/v${version}/contrib/completion/bash/docker
      type: file
      path: ${target}/share/bash-completion/completions/docker
    - url: https://github.com/docker/cli/raw/v${version}/contrib/completion/fish/docker.fish
      type: file
      path: ${target}/share/fish/vendor_completions.d/docker.fish
    - url: https://github.com/docker/cli/raw/v${version}/contrib/completion/zsh/_docker
      type: file
      path: ${target}/share/zsh/vendor-completions/_docker
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/systemd/docker.service
      type: file
      path: contrib/${tool}/systemd/docker.service
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/systemd/docker.socket
      type: file
      path: contrib/${tool}/systemd/docker.socket
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/sysvinit-debian/docker.default
      type: file
      path: contrib/${tool}/sysvinit/debian/docker.default
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/sysvinit-debian/docker
      type: file
      path: contrib/${tool}/sysvinit/debian/docker
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/sysvinit-redhat/docker.sysconfig
      type: file
      path: contrib/${tool}/sysvinit/redhat/docker.sysconfig
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/sysvinit-redhat/docker
      type: file
      path: contrib/${tool}/sysvinit/redhat/docker
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/openrc/docker.confd
      type: file
      path: contrib/${tool}/openrc/docker.confd
    - url: https://github.com/moby/moby/raw/v${version}/contrib/init/openrc/docker.initd
      type: file
      path: contrib/${tool}/openrc/docker.initd
    post_install: |
      echo "Move binaries (@ ${SECONDS} seconds)"
      mv "${target}/libexec/docker/bin/dockerd" "${target}/bin"
      mv "${target}/libexec/docker/bin/docker" "${target}/bin"
      mv "${target}/libexec/docker/bin/docker-proxy" "${target}/bin"
      echo "Move rootless scripts (@ ${SECONDS} seconds)"
      mv "${target}/libexec/docker/bin/dockerd-rootless.sh" "${target}/bin"
      mv "${target}/libexec/docker/bin/dockerd-rootless-setuptool.sh" "${target}/bin"
      echo "Binaries installed after ${SECONDS} seconds."
      if docker_is_running; then
          touch "${docker_setup_cache}/docker_already_present"
          echo "Found that Docker is already present after ${SECONDS} seconds."
          warning "Docker is already running. Skipping systemd unit, init script and daemon configuration."

      else
          echo "Install systemd units (@ ${SECONDS} seconds)"
          cp "${docker_setup_contrib}/${tool}/systemd/docker.service" "${prefix}/etc/systemd/system/docker.service"
          cp "${docker_setup_contrib}/${tool}/systemd/docker.socket" "${prefix}/etc/systemd/system/docker.socket"
          sed -i "/^\[Service\]/a Environment=PATH=${relative_target}/libexec/docker/bin:/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin" "${prefix}/etc/systemd/system/docker.service"
          sed -i -E "s|/usr/bin/dockerd|${relative_target}/bin/dockerd|" "${prefix}/etc/systemd/system/docker.service"
          if is_debian || is_clearlinux; then
              echo "Install init script for debian"
              cp "${docker_setup_contrib}/${tool}/sysvinit/debian/docker.default" "${prefix}/etc/default/docker"
              cp "${docker_setup_contrib}/${tool}/sysvinit/debian/docker" "${prefix}/etc/init.d/docker"
              sed -i -E "s|^(export PATH=)|\1${relative_target}/libexec/docker/bin:|" "${prefix}/etc/init.d/docker"
              sed -i -E "s|^DOCKERD=/usr/bin/dockerd|DOCKERD=${relative_target}/bin/dockerd|" "${prefix}/etc/init.d/docker"
              chmod +x "${prefix}/etc/init.d/docker"
          elif is_redhat; then
              echo "Install init script for redhat"
              cp "${docker_setup_contrib}/${tool}/sysvinit/redhat/docker.sysconfig" "${prefix}/etc/sysconfig/docker"
              cp "${docker_setup_contrib}/${tool}/sysvinit/redhat/docker" "${prefix}/etc/init.d/docker"
              # shellcheck disable=SC1083
              sed -i -E "s|(^prog=)|export PATH="${relative_target}/libexec/docker/bin:${relative_target}/sbin:${relative_target}/bin:\${PATH}"\n\n\1|" "${prefix}/etc/init.d/docker"
              sed -i -E "s|/usr/bin/dockerd|${relative_target}/bin/dockerd|" "${prefix}/etc/init.d/docker"
              chmod +x "${prefix}/etc/init.d/docker"
          elif is_alpine; then
              echo "Install openrc script for alpine"
              cp "${docker_setup_contrib}/${tool}/openrc/docker.confd" "${prefix}/etc/conf.d/docker"
              cp "${docker_setup_contrib}/${tool}/openrc/docker.initd" "${prefix}/etc/init.d/docker"
              # shellcheck disable=1083
              sed -i -E "s|^(command=)|export PATH="${relative_target}/libexec/docker/bin:\${PATH}"\n\n\1|" "${prefix}/etc/init.d/docker"
              sed -i "s|/usr/bin/dockerd|${relative_target}/bin/dockerd|" "${prefix}/etc/init.d/docker"
              sed -i "s|/usr/bin/dockerd|${relative_target}/bin/dockerd|" "${prefix}/etc/conf.d/docker"
              chmod +x "${prefix}/etc/init.d/docker"
              openrc
          else
              warning "Unable to install init script because the distributon is unknown."
          fi
          if ! has_systemd && ! test -f "${prefix}/etc/init.d/docker"; then
              error "Systemd not available but unable to provide init script."
              exit 1
          fi
          if test -z "${prefix}"; then
              echo "Create group (@ ${SECONDS} seconds)"
              groupadd --system --force docker
          fi
          echo "Configure daemon (@ ${SECONDS} seconds)"
          if ! test -f "${prefix}/etc/docker/daemon.json"; then
              echo "Initialize dockerd configuration"
              echo "{}" >"${prefix}/etc/docker/daemon.json"
          fi
          local root_fs
          root_fs="$(mount | grep " on / " | cut -d' ' -f5)"
          echo "Found ${root_fs} on /"
          if test "${root_fs}" == "overlay"; then
              echo "Configuring storage driver for DinD"
              # shellcheck disable=SC2094
              cat <<< "$(jq '. * {"storage-driver": "fuse-overlayfs"}' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
              if has_tool "fuse-overlayfs"; then
                  info "Found fuse-overlayfs"
                  
              elif tool_will_be_installed "fuse-overlayfs"; then
                  info "Waiting for fuse-overlayfs to be installed"
                  wait_for_tool "fuse-overlayfs" "${target}/bin"

              else
                  error "fuse-overlayfs must be planned for installation."
                  exit 1
              fi
              touch "${docker_setup_cache}/docker_restart"
          fi

          if ! test "$(jq '."exec-opts" // [] | any(. | startswith("native.cgroupdriver="))' "${prefix}/etc/docker/daemon.json")" == "true"; then
              echo "Configuring native cgroup driver"
              # shellcheck disable=SC2094
              cat <<< "$(jq '."exec-opts" += ["native.cgroupdriver=cgroupfs"]' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
              touch "${docker_setup_cache}/docker_restart"
          fi
          if ! test "$(jq '. | keys | any(. == "default-runtime")' "${prefix}/etc/docker/daemon.json")" == true; then
              echo "Set default runtime"
              # shellcheck disable=SC2094
              cat <<< "$(jq '. * {"default-runtime": "runc"}' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
              touch "${docker_setup_cache}/docker_restart"
          fi
          # shellcheck disable=SC2016
          if test -n "${docker_address_base}" && test -n "${docker_address_size}" && ! test "$(jq --arg base "${docker_address_base}" --arg size "${docker_address_size}" '."default-address-pool" | any(.base == $base and .size == $size)' "${prefix}/etc/docker/daemon.json")" == "true"; then
              echo "Add address pool with base ${docker_address_base} and size ${docker_address_size}"
              # shellcheck disable=SC2094
              cat <<< "$(jq --args base "${docker_address_base}" --arg size "${docker_address_size}" '."default-address-pool" += {"base": $base, "size": $size}' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
              touch "${docker_setup_cache}/docker_restart"
          fi
          # shellcheck disable=SC2016
          if test -n "${docker_registry_mirror}" && ! test "$(jq --arg mirror "${docker_registry_mirror}" '."registry-mirrors" // [] | any(. == $mirror)' "${prefix}/etc/docker/daemon.json")" == "true"; then
              echo "Add registry mirror ${docker_registry_mirror}"
              # shellcheck disable=SC2094
              # shellcheck disable=SC2016
              cat <<< "$(jq --args mirror "${docker_registry_mirror}" '."registry-mirrors" += ["\($mirror)"]' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
              touch "${docker_setup_cache}/docker_restart"
          fi
          if ! test "$(jq --raw-output '.features.buildkit // false' "${prefix}/etc/docker/daemon.json")" == true; then
              echo "Enable BuildKit"
              # shellcheck disable=SC2094
              cat <<< "$(jq '. * {"features":{"buildkit":true}}' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
              touch "${docker_setup_cache}/docker_restart"
          fi
          echo "Check if daemon.json is valid JSON (@ ${SECONDS} seconds)"
          if ! jq --exit-status '.' "${prefix}/etc/docker/daemon.json" >/dev/null 2>&1; then
              error "${prefix}/etc/docker/daemon.json is not valid JSON."
              exit 1
          fi
          if test -z "${prefix}"; then
              if has_systemd; then
                  echo "Reload systemd (@ ${SECONDS} seconds)"
                  systemctl daemon-reload
                  if ! systemctl is-active --quiet docker; then
                      echo "Start dockerd (@ ${SECONDS} seconds)"
                      systemctl enable docker
                      systemctl start docker
                      touch "${docker_setup_cache}/docker_restart_allowed"
                  fi
              else
                  if ! docker_is_running; then
                      echo "Start dockerd (@ ${SECONDS} seconds)"
                      "${prefix}/etc/init.d/docker" start
                      touch "${docker_setup_cache}/docker_restart_allowed"
                  fi
                  warning "Init script was installed but you must enable Docker yourself."
              fi
          fi
          echo "Wait for Docker daemon to start (@ ${SECONDS} seconds)"
          wait_for_docker
          if ! docker_is_running; then
              error "Failed to start Docker."
              exit 1
          fi
          echo "Finished starting Docker after ${SECONDS} seconds."
      fi
      if ${skip_docs}; then
          warning "Installation of manpages will be skipped."

      else
          echo "Install manpages for Docker CLI"
          "${target}/bin/docker" container run \
              --interactive \
              --rm \
              --volume "${target}/share/man:/opt/man" \
              --env version \
              --workdir /go/src/github.com/docker/cli \
              "golang:${go_version}" bash \
              <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/docker/cli .
      export GO111MODULE=auto
      export DISABLE_WARN_OUTSIDE_CONTAINER=1
      sed -i -E 's|^(\s+)(log.Printf\("WARN:)|\1//\2|' man/generate.go
      sed -i -E 's|^(\s+)"log"||' man/generate.go
      make manpages
      cp -r man/man1 /opt/man
      cp -r man/man5 /opt/man
      cp -r man/man8 /opt/man
      EOF
      fi
      echo "Finished after ${SECONDS} seconds."

  - name: docker-compose-v1
    version: 1.29.2
    check: ${binary} version --short
    flags: 
    - docker-compose-v1
    tags:
    - default
    - docker
    - compose
    download:
    - url:
        x86_64: https://github.com/docker/compose/releases/download/1.29.2/docker-compose-Linux-x86_64
      type: executable
    files:
    - path: ${target}/bin/docker-compose
      content: |
        #!/bin/bash

        docker_cli_plugin_metadata() {
          if [ -z "$DOCKER_COMPOSE_VERSION" ]; then
            export DOCKER_COMPOSE_VERSION
                DOCKER_COMPOSE_VERSION="$(docker-compose --version | cut -d " " -f 3 | cut -d "," -f 1)"
          fi

          local vendor="Docker"
          local url="https://www.docker.com"
          local description="Define and run multi-container applications"
          cat <<-EOF
          {"SchemaVersion":"0.1.0","Vendor":"${vendor}","Version":"${DOCKER_COMPOSE_VERSION}","ShortDescription":"${description}","URL":"${url}"}
        EOF
        }

        case "$1" in
          docker-cli-plugin-metadata)
            docker_cli_plugin_metadata
            ;;
          *)
            shift
            exec docker-compose "$@"
            ;;
        esac

  - name: docker-compose-switch
    version: 1.0.5
    binary: docker-compose
    flags:
    - not-docker-compose-v1
    tags:
    - default
    download:
    - url: https://github.com/docker/compose-switch/releases/download/v${version}/docker-compose-linux-${alt_arch}
      type: executable

  - name: docker-compose
    version: 2.9.0
    binary: ${target}/libexec/docker/cli-plugins/docker-compose
    check: ${binary} compose version --short
    needs:
    - docker
    - docker-compose-switch
    flags:
    - not-docker-compose-v1
    tags:
    - default
    - docker
    - compose
    - plugin
    download:
    - url: https://github.com/docker/compose/releases/download/v${version}/docker-compose-linux-${arch}
      type: executable

  - name: docker-credential-acr-env
    version: 0.7.0
    needs:
    - docker
    tags:
    - docker
    - security
    download:
    - url: https://github.com/chrismellard/docker-credential-acr-env/releases/download/${version}/docker-credential-acr-env_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - docker-credential-acr-env

  - name: docker-credential-ecr-login
    version: 0.6.0
    needs:
    - docker
    tags:
    - docker
    - security
    download:
    - url: https://amazon-ecr-credential-helper-releases.s3.us-east-2.amazonaws.com/${version}/linux-${alt_arch}/docker-credential-ecr-login
      type: executable
      
  - name: docker-credential-gcr
    version: 2.1.5
    needs:
    - docker
    tags:
    - docker
    - security
    download:
    - url: https://github.com/GoogleCloudPlatform/docker-credential-gcr/releases/download/v${version}/docker-credential-gcr_linux_${alt_arch}-${version}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - docker-credential-gcr
      
  - name: docker-credential-helpers
    version: 0.6.4
    binary: docker-credential-pass
    needs:
    - docker
    tags:
    - docker
    - security
    download:
    - url:
        x86_64: https://github.com/docker/docker-credential-helpers/releases/download/v${version}/docker-credential-pass-v${version}-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
    - url:
        x86_64: https://github.com/docker/docker-credential-helpers/releases/download/v${version}/docker-credential-secretservice-v${version}-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      
  - name: docker-credential-magic
    version: 0.8.1
    needs:
    - docker
    tags:
    - docker
    - security
    download:
    - url:
        x86_64: https://github.com/docker-credential-magic/docker-credential-magic/releases/download/v${version}/docker-credential-magic_Linux_${arch}.tar.gz
        aarch64: https://github.com/docker-credential-magic/docker-credential-magic/releases/download/v${version}/docker-credential-magic_Linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - docker-credential-magic
      - docker-credential-magician

  - name: docker-machine
    version: 0.16.2
    check: ${binary} --version | cut -d, -f1 | cut -d' ' -f3
    tags:
    - docker
    download:
    - url: https://github.com/docker/machine/releases/download/v${version}/docker-machine-Linux-${arch}
      type: executable

  - name: docker-sbom
    version: 0.6.1
    binary: ${target}/libexec/docker/cli-plugins/docker-sbom
    needs:
    - docker
    tags:
    - docker
    - security
    - sbom
    download:
    - url: https://github.com/docker/sbom-cli-plugin/releases/download/v${version}/sbom-cli-plugin_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/libexec/docker/cli-plugins
      files:
      - docker-sbom

  - name: docker-scan
    version: 0.17.0
    binary: ${target}/libexec/docker/cli-plugins/docker-scan
    needs:
    - docker
    tags:
    - docker
    - security
    - plugin
    download:
    - url: https://github.com/docker/scan-cli-plugin/releases/download/v${version}/docker-scan_linux_${alt_arch}
      type: executable

  - name: docuum
    version: 0.21.1
    check: ${binary} --version | cut -d' ' -f2
    needs:
    - docker
    tags:
    - docker
    - management
    dockerfile: |
      FROM rust:${rust_version}
    install: |
      docker_run \
          --workdir /go/src/github.com/stepchowfun/docuum \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/stepchowfun/docuum .
      export RUSTFLAGS='-C target-feature=+crt-static'
      cargo build --release --target x86_64-unknown-linux-gnu
      cp target/x86_64-unknown-linux-gnu/release/docuum /target/bin/
      EOF

  - name: dry
    version: 0.11.1
    check: ${binary} --version | cut -d, -f1 | cut -d' ' -f3
    needs:
    - docker
    tags:
    - analysis
    - management
    - tui
    download:
    - url: https://github.com/moncho/dry/releases/download/v${version}/dry-linux-${alt_arch}
      type: executable

  - name: duffle
    version: 0.3.5-beta.1
    check: ${binary} version
    tags:
    - cnab
    download:
    - url: https://github.com/cnabio/duffle/releases/download/${version}/duffle-linux-${alt_arch}
      type: executable

  - name: dyff
    version: 1.5.4
    check: ${binary} version | cut -d' ' -f3
    tags:
    - development
    - dev
    download:
    - url: https://github.com/homeport/dyff/releases/download/v${version}/dyff_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - dyff
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/dyff"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/dyff.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_dyff"

  - name: faas-cli
    version: 0.14.2
    check: ${binary} version | grep "version:" | cut -d' ' -f3
    tags:
    - serverless
    - faas
    download:
    - url:
        x86_64: https://github.com/openfaas/faas-cli/releases/download/${version}/faas-cli
        aarch64: https://github.com/openfaas/faas-cli/releases/download/${version}/faas-cli-${alt_arch}
      type: executable

  - name: faasd
    version: 0.16.2
    check: ${binary} version | grep faasd | tr '\t' ' ' | cut -d' ' -f3
    needs:
    - containerd
    - faas-cli
    tags:
    - serverless
    - faas
    download:
    - url:
        x86_64: https://github.com/openfaas/faasd/releases/download/${version}/faasd
        aarch64: https://github.com/openfaas/faasd/releases/download/${version}/faasd-${alt_arch}
      type: executable

  - name: firecracker
    version: 1.1.1
    check: ${binary} --version | grep "^Firecracker" | cut -d' ' -f2 | tr -d v
    tags:
    - kvm
    - vm
    - emulation
    download:
    - url: https://github.com/firecracker-microvm/firecracker/releases/download/v${version}/firecracker-v${version}-${arch}.tgz
      type: tarball
      path: ${target}/bin
      strip: 1
      files:
      - release-v${version}-${arch}/firecracker-v${version}-${arch}
      - release-v${version}-${arch}/jailer-v${version}-${arch}
      - release-v${version}-${arch}/seccompiler-bin-v${version}-${arch}
    post_install: |
      mv "${target}/bin/firecracker-v${version}-${arch}"     "${target}/bin/firecracker"
      mv "${target}/bin/jailer-v${version}-${arch}"          "${target}/bin/jailer"
      mv "${target}/bin/seccompiler-bin-v${version}-${arch}" "${target}/bin/seccompiler-bin"

  - name: firectl
    version: 0.1.0
    check: ${binary} --version
    needs:
    - firecracker
    tags:
    - kvm
    - management
    - vm
    - emulation
    download:
    - url:
        x86_64: https://firectl-release.s3.amazonaws.com/firectl-v${version}
      type: executable

  - name: footloose
    version: 0.6.3
    check: ${binary} version | cut -d' ' -f2
    tags:
    - vm
    - emulation
    download:
    - url: https://github.com/weaveworks/footloose/releases/download/${version}/footloose-${version}-linux-${arch}
      type: executable
  
  - name: fuse-overlayfs
    version: 1.9
    check: ${binary} --version | head -n 1 | cut -d' ' -f3
    tags:
    - default
    - docker
    - storage
    - containerd
    download:
    - url: https://github.com/containers/fuse-overlayfs/releases/download/v${version}/fuse-overlayfs-${arch}
      type: executable

  - name: fuse-overlayfs-snapshotter
    version: 1.0.4
    binary: containerd-fuse-overlayfs-grpc
    needs:
    - fuse-overlayfs
    - containerd
    tags:
    - storage
    - containerd
    download:
    - url: https://github.com/containerd/fuse-overlayfs-snapshotter/releases/download/v${version}/containerd-fuse-overlayfs-${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
    files:
    - path: contrib/${tool}/fuse-overlayfs-snapshotter.service
      content: |
        [Unit]
        Description=containerd-fuse-overlayfs
        PartOf=containerd

        [Service]
        ExecStart=/usr/local/bin/containerd-fuse-overlayfs-grpc "/var/run/containerd-fuse-overlayfs.sock" "/var/lib/containerd-fuse-overlayfs"
        ExecReload=/bin/kill -s HUP \$MAINPID
        RestartSec=2
        Restart=always
        Type=simple
        KillMode=mixed

        [Install]
        WantedBy=default.target
    post_install: |
      echo "Add configuration to containerd"
      cat >"${docker_setup_cache}/containerd-config.toml-fuse-overlayfs-snapshotter.sh" <<EOF
      "${target}/bin/dasel" put object --file "${prefix}/etc/containerd/config.toml" --parser toml --type string --type string proxy_plugins."fuse_overlayfs" type=snapshot address=/var/run/containerd-fuse-overlayfs.sock
      EOF
      echo "Install systemd units"
      cp "${docker_setup_contrib}/${tool}/fuse-overlayfs-snapshotter.service" "${prefix}/etc/systemd/system/fuse-overlayfs-snapshotter.service"
      sed -i "s|ExecStart=/usr/local/bin/containerd-fuse-overlayfs-grpc|ExecStart=${relative_target}/bin/containerd-fuse-overlayfs-grpc|" "${prefix}/etc/systemd/system/fuse-overlayfs-snapshotter.service"
      if test -z "${prefix}"; then
          if has_systemd; then
              echo "Reload systemd"
              systemctl daemon-reload
          fi
      fi

  - name: glow
    version: 1.4.1
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - markdown
    download:
    - url: https://github.com/charmbracelet/glow/releases/download/v${version}/glow_${version}_linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - glow

  - name: grype
    version: 0.46.0
    check: ${binary} version | grep "^Version:" | tr -s ' ' | cut -d' ' -f2
    tags:
    - security
    - sbom
    download:
    - url: https://github.com/anchore/grype/releases/download/v0.34.3/grype_0.34.3_linux_amd64.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - grype
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/grype"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/grype.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_grype"

  - name: gvisor
    version: 20220801
    binary: ${target}/bin/runsc
    check: ${binary} --version | grep "runsc version" | cut -d' ' -f3
    needs:
    - docker
    tags:
    - runtime
    - security
    download:
    - url: https://storage.googleapis.com/gvisor/releases/release/${version}/${arch}/runsc
      type: executable
    - url: https://storage.googleapis.com/gvisor/releases/release/${version}/${arch}/containerd-shim-runsc-v1
      type: executable
      path: ${target}/bin/containerd-shim-runsc-v1
    post_install: |
      if ! test -f "${prefix}/etc/docker/daemon.json" || ! test "$(jq --raw-output '.runtimes | keys | any(. == "runsc")' "${prefix}/etc/docker/daemon.json")" == "true"; then
          echo "Add runtime to Docker"
          # shellcheck disable=SC2094
          cat >"${docker_setup_cache}/daemon.json-gvisor.sh" <<EOF
      cat <<< "\$(jq --arg target "${target}" '. * {"runtimes":{"runsc":{"path":"\(\$target)/bin/runsc"}}}' "${prefix}/etc/docker/daemon.json")" >"${prefix}/etc/docker/daemon.json"
      EOF
          touch "${docker_setup_cache}/docker_restart"
      fi

  - name: hadolint
    version: 2.10.0
    check: ${binary} --version | cut -d' ' -f4 | cut -d- -f1
    tags:
    - docker
    - build
    - analysis
    download:
    - url:
        x86_64: https://github.com/hadolint/hadolint/releases/download/v${version}/hadolint-Linux-${arch}
      type: executable

  - name: hcloud
    version: 1.30.1
    check: ${binary} version | cut -d' ' -f2
    tags:
    - cloud
    - management
    download:
    - url: https://github.com/hetznercloud/cli/releases/download/v${version}/hcloud-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - hcloud

  - name: helm
    version: 3.9.2
    check: ${binary} version --short | cut -d+ -f1 | tr -d v
    tags:
    - k8s
    - kubernetes
    - templating
    - package
    - manager
    download:
    - url: https://get.helm.sh/helm-v${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      strip: 1
      files:
      - linux-amd64/helm
    post_install: |
      "${binary}" completion bash >"${target}/share/bash-completion/completions/helm"
      "${binary}" completion fish >"${target}/share/fish/vendor_completions.d/helm.fish"
      "${binary}" completion zsh >"${target}/share/zsh/vendor-completions/_helm"
      if test -z "${prefix}"; then
          echo "Install plugins"
          plugins=(
              https://github.com/mstrzele/helm-edit
              https://github.com/databus23/helm-diff
              https://github.com/aslafy-z/helm-git
              https://github.com/sstarcher/helm-release
              https://github.com/maorfr/helm-backup
              https://github.com/technosophos/helm-keybase
              https://github.com/technosophos/helm-gpg
              https://github.com/cloudogu/helm-sudo
              https://github.com/bloodorangeio/helm-oci-mirror
              https://github.com/UniKnow/helm-outdated
              https://github.com/rimusz/helm-chartify
              https://github.com/random-dwi/helm-doc
              https://github.com/sapcc/helm-outdated-dependencies
              https://github.com/jkroepke/helm-secrets
              https://github.com/sigstore/helm-sigstore
              https://github.com/quintush/helm-unittest
          )
          for url in "${plugins[@]}"; do
              directory="$(basename "${url}")"
              if test -d "${HOME}/.local/share/helm/plugins/${directory}"; then
                  name="${directory//helm-/}"
                  helm plugin update "${name}"
              else
                  helm plugin install "${url}"
              fi
          done
      fi

  - name: helmfile
    version: 0.144.0
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    tags:
    - k8s
    - kubernetes
    - templating
    download:
    - url: https://github.com/roboll/helmfile/releases/download/v${version}/helmfile_linux_${alt_arch}
      type: executable
    - url: https://github.com/roboll/helmfile/raw/v${version}/autocomplete/helmfile_bash_autocomplete
      type: file
      path: ${target}/share/bash-completion/completions/helmfile
    - url: https://github.com/roboll/helmfile/raw/v${version}/autocomplete/helmfile_zsh_autocomplete
      type: file
      path: ${target}/share/zsh/vendor-completions/_helmfile

  - name: hub-tool
    version: 0.4.5
    check: ${binary} --version | cut -d, -f1 | cut -d' ' -f4 | tr -d v
    tags:
    - docker
    download:
    - url: https://github.com/docker/hub-tool/releases/download/v${version}/hub-tool-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      strip: 1
      files:
      - hub-tool/hub-tool

  - name: ignite
    version: 0.10.0
    check: ${binary} version --output short | tr -d v
    needs:
    - containerd
    - cni
    tags:
    - kvm
    - management
    - vm
    - emulation
    download:
    - url: https://github.com/weaveworks/ignite/releases/download/v${version}/ignite-${alt_arch}
      type: executable
    - url: https://github.com/weaveworks/ignite/releases/download/v${version}/ignited-${alt_arch}
      type: executable
      path: ${target}/bin/ignited
    post_install: |
      echo "Install completion"
      ${binary} completion >"${target}/share/bash-completion/completions/ignite"
      "${target}/bin/ignited" completion >"${target}/share/bash-completion/completions/ignited" || true

  - name: img
    version: 0.5.11
    check: ${binary} --version | cut -d, -f1 | cut -d' ' -f3 | tr -d v
    tags:
    - build
    - oci
    download:
    - url: https://github.com/genuinetools/img/releases/download/v${version}/img-linux-${alt_arch}
      type: executable

  - name: imgcrypt
    version: 1.1.6
    binary: ctr-enc
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    needs:
    - containerd
    - docker
    tags:
    - containerd
    - security
    dockerfile: |
      FROM golang:${go_version}
    install: |
      docker_run \
          --workdir /go/src/github.com/containerd/imgcrypt \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/containerd/imgcrypt .
      sed -i -E 's/ -v / /' Makefile
      sed -i -E "s/ --dirty='.m' / /" Makefile
      make
      make install DESTDIR=/target
      EOF

  - name: imgpkg
    version: 0.30.0
    check: ${binary} version | head -n 1 | cut -d' ' -f3
    tags:
    - oci
    - registry
    - management
    download:
    - url: https://github.com/vmware-tanzu/carvel-imgpkg/releases/download/v${version}/imgpkg-linux-${alt_arch}
      type: executable

  - name: iptables
    version: 1.8.8
    if: |
      is_centos_7 || is_amzn_2 || is_rockylinux
    tags:
    - network
    install: |
      if is_centos_7 || is_amzn_2; then
          get_file "https://github.com/nicholasdille/centos-iptables-legacy/releases/download/v${version}/iptables-centos7-${alt_arch}.tar.gz" \
          | tar -xz \
              --directory "${target}" \
              --no-same-owner

      elif is_centos_8 || is_rockylinux; then
          get_file "https://github.com/nicholasdille/centos-iptables-legacy/releases/download/v${version}/iptables-centos8-${alt_arch}.tar.gz" \
          | tar -xz \
              --directory "${target}" \
              --no-same-owner
      fi

  - name: jp
    version: 0.2.1
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - conversion
    - format
    download:
    - url: https://github.com/jmespath/jp/releases/download/${version}/jp-linux-${alt_arch}
      type: executable
  
  - name: jwt
    version: 5.0.3
    check: ${binary} --version | cut -d' ' -f2
    needs:
    - docker
    tags:
    - security
    dockerfile: |
      FROM rust:${rust_version}
    install: |
      docker_run \
          --workdir /go/src/github.com/mike-engel/jwt-cli \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "${version}" https://github.com/mike-engel/jwt-cli .
      export RUSTFLAGS='-C target-feature=+crt-static'
      cargo build --release --target x86_64-unknown-linux-gnu
      cp target/x86_64-unknown-linux-gnu/release/jwt /target/bin/
      EOF

  - name: k3d
    version: 5.3.0
    check: ${binary} version | head -n 1 | cut -d' ' -f3 | tr -d v
    needs:
    - docker
    tags:
    - k8s
    - kubernetes
    - docker
    - management
    download:
    - url: https://github.com/rancher/k3d/releases/download/v${version}/k3d-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/k3d"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/k3d.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_k3d"

  - name: k3s
    version: 1.23.4+k3s1
    check: ${binary} --version | head -n 1 | cut -d' ' -f3 | tr -d v
    tags:
    - k8s
    - kubernetes
    download:
    - url:
        x86_64: https://github.com/k3s-io/k3s/releases/download/v${version}/k3s
        aarch64: https://github.com/k3s-io/k3s/releases/download/v${version}/k3s-arm64
      type: executable
    files:
    - path: ${prefix}/etc/init.d/k3s
      content: |
        [Unit]
        Description=Lightweight Kubernetes
        Documentation=https://k3s.io
        Wants=network-online.target
        After=network-online.target

        [Install]
        WantedBy=multi-user.target

        [Service]
        Type=notify
        EnvironmentFile=-/etc/default/%N
        EnvironmentFile=-/etc/sysconfig/%N
        KillMode=process
        Delegate=yes
        # Having non-zero Limit*s causes performance problems due to accounting overhead
        # in the kernel. We recommend using cgroups to do container-local accounting.
        LimitNOFILE=1048576
        LimitNPROC=infinity
        LimitCORE=infinity
        TasksMax=infinity
        TimeoutStartSec=0
        Restart=always
        RestartSec=5s
        ExecStartPre=/bin/sh -xc '! /usr/bin/systemctl is-enabled --quiet nm-cloud-setup.service'
        ExecStartPre=-/sbin/modprobe br_netfilter
        ExecStartPre=-/sbin/modprobe overlay
        ExecStart=/usr/local/bin/k3s
    post_install: |
      echo "Fix systemd unit"
      sed -i "s|/usr/local/bin/k3s|${relative_target}/bin/k3s|g" "${prefix}/etc/systemd/system/k3s.service"
      if test -z "${prefix}"; then
          if has_systemd; then
              echo "Reload systemd"
              systemctl daemon-reload
          fi
      fi

  - name: k3sup
    version: 0.11.3
    check: ${binary} version | grep Version | cut -d' ' -f2
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url:
        x86_64: https://github.com/alexellis/k3sup/releases/download/${version}/k3sup
        aarch64: https://github.com/alexellis/k3sup/releases/download/${version}/k3sup.${alt_arch}
      type: executable

  - name: k9s
    version: 0.25.18
    check: ${binary} version --short | grep "^Version" | cut -dv -f2
    tags:
    - k8s
    - kubernetes
    - management
    - tui
    download:
    - url: https://github.com/derailed/k9s/releases/download/v${version}/k9s_Linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - k9s

  - name: kapp
    version: 0.51.0
    check: ${binary} version | head -n 1 | cut -d' ' -f3
    tags:
    - k8s
    - kubernetes
    - templating
    - package
    - manager
    download:
    - url: https://github.com/vmware-tanzu/carvel-kapp/releases/download/v${version}/kapp-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash | grep -v "^Succeeded$" >"${target}/share/bash-completion/completions/kapp"
      ${binary} completion fish | grep -v "^Succeeded$" >"${target}/share/fish/vendor_completions.d/kapp.fish"
      ${binary} completion zsh  | grep -v "^Succeeded$" >"${target}/share/zsh/vendor-completions/_kapp"

  - name: kbld
    version: 0.34.0
    check: ${binary} version | head -n 1 | cut -d' ' -f3
    tags:
    - k8s
    - kubernetes
    - build
    download:
    - url: https://github.com/vmware-tanzu/carvel-kbld/releases/download/v${version}/kbld-linux-${alt_arch}
      type: executable

  - name: kbrew
    version: 0.1.0
    check: ${binary} version | cut -d, -f1 | cut -d'"' -f4 | tr -d v
    tags:
    - k8s
    - kubernetes
    - package
    - manager
    download:
    - url: https://github.com/kbrew-dev/kbrew/releases/download/v${version}/kbrew_${version}_Linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - kbrew

  - name: kind
    version: 0.14.0
    check: ${binary} version | cut -d' ' -f1-2 | cut -d' ' -f2 | tr -d v
    tags:
    - k8s
    - kubernetes
    - docker
    - management
    needs:
    - docker
    download:
    - url: https://github.com/kubernetes-sigs/kind/releases/download/v${version}/kind-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/kind"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/kind.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_kind"

  - name: kink
    version: 0.2.1
    check: ${binary} version | grep GitVersion | tr -s ' ' | cut -d' ' -f2
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url: https://github.com/Trendyol/kink/releases/download/v${version}/kink_${version}_Linux-${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - kink
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/kink"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/kink.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_kink"

  - name: kompose
    version: 1.26.1
    check: ${binary} version | cut -d' ' -f1
    tags:
    - k8s
    - kubernetes
    - compose
    download:
    - url: https://github.com/kubernetes/kompose/releases/download/v${version}/kompose-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/kompose"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/kompose.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_kompose"

  - name: kots
    version: 1.79.0
    binary: kubectl-kots
    check: ${binary} version | cut -d' ' -f3
    download:
    - url: https://github.com/replicatedhq/kots/releases/download/v${version}/kots_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - kots
    post_install: |
      mv "${target}/bin/kots" "${target}/bin/kubectl-kots"
      echo "Install completion"
      ${binary} completion bash 2>/dev/null >"${target}/share/bash-completion/completions/${name}"
      ${binary} completion fish 2>/dev/null >"${target}/share/fish/vendor_completions.d/${name}.fish"
      ${binary} completion zsh 2>/dev/null >"${target}/share/zsh/vendor-completions/_${name}"

  - name: krew
    version: 0.4.3
    check: ${binary} version 2>/dev/null | grep GitTag | tr -s ' ' | cut -d' ' -f2 | tr -d v
    tags:
    - k8s
    - kubernetes
    - plugin
    - management
    download:
    - url: https://github.com/kubernetes-sigs/krew/releases/download/v${version}/krew-linux_${alt_arch}.tar.gz
      type: tarball
      strip: 1
      path: "${target}/bin"
      files:
      - ./krew-linux_${alt_arch}
    post_install: |
      mv "${target}/bin/krew-linux_${alt_arch}" "${target}/bin/krew"
      echo "Add to path"
      cat >"${prefix}/etc/profile.d/krew.sh" <<"EOF"
      export PATH="${HOME}/.krew/bin:${PATH}"
      EOF
      echo "Install completion"
      ${binary} completion bash 2>/dev/null >"${target}/share/bash-completion/completions/krew"
      ${binary} completion fish 2>/dev/null >"${target}/share/fish/vendor_completions.d/krew.fish"
      ${binary} completion zsh 2>/dev/null >"${target}/share/zsh/vendor-completions/_krew"

  - name: kubeadm
    version: 1.24.3
    check: ${binary} version --output short | tr -d v
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url: https://storage.googleapis.com/kubernetes-release/release/v${version}/bin/linux/${alt_arch}/kubeadm
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash 2>/dev/null >"${target}/share/bash-completion/completions/kubeadm"
      ${binary} completion zsh 2>/dev/null >"${target}/share/zsh/vendor-completions/_kubeadm"

  - name: kubectl
    version: 1.24.3
    check: ${binary} version --client --short | cut -d' ' -f3 | tr -d v
    needs:
    - krew
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url: https://storage.googleapis.com/kubernetes-release/release/v${version}/bin/linux/${alt_arch}/kubectl
      type: executable
    - url: https://dl.k8s.io/release/v${version}/bin/linux/${alt_arch}/kubectl-convert
      type: executable
      path: ${target}/bin/kubectl-convert
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/kubectl"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_kubectl"
      echo "Add alias k"
      cat >"${prefix}/etc/profile.d/kubectl.sh" <<EOF
      alias k=kubectl
      complete -F __start_kubectl k
      EOF
      if test -z "${prefix}" && ( has_tool "krew" || tool_will_be_installed "krew" ); then
          echo "Waiting for krew"
          wait_for_tool "krew" "${target}/bin"
          echo "Install krew for current user"
          # shellcheck source=/dev/null
          source "${prefix}/etc/profile.d/krew.sh"
          krew update
          krew install krew
          plugins=(
              access-matrix
              advise-policy
              advise-psp
              assert
              blame
              bulk-action
              cert-manager
              cilium
              cyclonus
              debug-shell
              deprecations
              df-pv
              doctor
              edit-status
              emit-event
              evict-pod
              exec-as
              exec-cronjob
              fields
              flame
              fleet
              fuzzy
              gadget
              get-all
              graph
              grep
              hns
              images
              janitor
              kniff
              konfig
              kubesec-scan
              kurt
              lineage
              modify-secret
              mtail
              neat
              node-shell
              outdated
              pexec
              pod-dive
              pod-inspect
              pod-lens
              rbac-lookup
              rbac-tool
              rbac-view
              reliably
              resource-capacity
              resource-snapshot
              rolesum
              score
              skew
              slice
              sniff
              socks5-proxy
              spy
              sshd
              starboard
              status
              strace
              sudo
              support-bundle
              tap
              trace
              tree
              tunnel
              view-allocations
              view-utilization
              viewnode
              who-can
              whoami
          )
          for plugin in "${plugins[@]}"; do
              echo "Processing ${plugin}"
              if krew list | grep -q "^${plugin}"; then
                  krew update "${plugin}"
              else
                  krew install "${plugin}"
              fi
          done
      else
          warning "kubectl is missing krew. Plugins will not be installed."
          false
      fi

  - name: kubectl-build
    version: 0.1.6
    needs:
    - kubectl
    tags:
    - k8s
    - kubernetes
    - management
    - plugin
    - build
    download:
    - url:
        x86_64: https://github.com/vmware-tanzu/buildkit-cli-for-kubectl/releases/download/v${version}/linux-v${version}.tgz
      type: tarball
      path: ${target}/bin

  - name: kubectl-free
    version: 0.2.0
    check: ${binary} --version | cut -d' ' -f2 | tr -d ','
    needs:
    - kubectl
    tags:
    - k8s
    - kubernetes
    - management
    - plugin
    - analysis
    download:
    - url:
        x86_64: https://github.com/makocchi-git/kubectl-free/releases/download/v${version}/kubectl-free_${version}_Linux_${arch}.zip
      type: zip
      path: ${target}/bin
      files:
      - kubectl-free_${version}_Linux_${arch}/kubectl-free

  - name: kubectl-resources
    version: 0.2.0
    needs:
    - kubectl
    tags:
    - k8s
    - kubernetes
    - management
    - plugin
    - analysis
    download:
    - url: https://github.com/howardjohn/kubectl-resources/releases/download/v${version}/kubectl-resources_${version}_Linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - kubectl-resources

  - name: kubefire
    version: 0.3.8
    check: ${binary} version | grep "^Version:" | cut -d' ' -f2 | tr -d v
    tags:
    - k8s
    - kubernetes
    - kvm
    - management
    - vm
    - emulation
    download:
    - url: https://github.com/innobead/kubefire/releases/download/v${version}/kubefire-linux-${alt_arch}
      type: executable
    - url: https://github.com/innobead/kubefire/releases/download/v${version}/host-local-rev-linux-${alt_arch}
      type: executable
      path: ${target}/libexec/cni/host-local-rev

  - name: kubelet
    version: 1.24.3
    check: ${binary} --version | cut -d' ' -f2 | tr -d v
    tags:
    - k8s
    - kubernetes
    download:
    - url: https://storage.googleapis.com/kubernetes-release/release/v${version}/bin/linux/${alt_arch}/kubelet
      type: executable

  - name: kubeletctl
    version: 1.8
    check: ${binary} version | grep "^Version:" | cut -d' ' -f2
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url: https://github.com/cyberark/kubeletctl/releases/download/v${version}/kubeletctl_linux_${alt_arch}
      type: executable

  - name: kubeswitch
    version: 1.5.0
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url: https://github.com/danielb42/kubeswitch/releases/download/v${version}/kubeswitch_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - kubeswitch

  - name: kubeval
    version: 0.16.1
    check: ${binary} --version | grep ^Version | cut -d' ' -f2
    tags:
    - k8s
    - kubernetes
    - security
    download:
    - url:
        x86_64: https://github.com/instrumenta/kubeval/releases/download/v0.16.1/kubeval-linux-amd64.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - kubeval

  - name: kubo
    version: 0.14.0
    check: ${binary} version --number
    needs:
    - containerd
    tags:
    - storage
    - network
    - containerd
    download:
    - url: https://github.com/ipfs/kubo/releases/download/v${version}/kubo_v${version}_linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      strip: 1
      files:
      - kubo/ipfs
    files:
    - path: ${prefix}/etc/systemd/system/ipfs.service
      content: |
        [Unit]
        Description=ipfs daemon
        PartOf=containerd

        [Service]
        Environment=IPFS_PATH=/var/lib/ipfs
        ExecStart=/usr/local/bin/ipfs daemon $@
        ExecReload=/bin/kill -s HUP \$MAINPID
        RestartSec=2
        Restart=always
        Type=simple
        KillMode=mixed

        [Install]
        WantedBy=default.target
    - path: ${prefix}/etc/containerd/conf.d/ipfs.toml
      content: |
        ipfs = true
    post_install: |
      echo "Install completion"
      ${binary} commands completion bash >"${target}/share/bash-completion/completions/ipfs"
      echo "Preconfigure ipfs"
      IPFS_PATH=${target}/var/lib/ipfs ${binary} init
      IPFS_PATH=${target}/var/lib/ipfs ${binary} config Addresses.API "/ip4/127.0.0.1/tcp/5888"
      IPFS_PATH=${target}/var/lib/ipfs ${binary} config Addresses.Gateway "/ip4/127.0.0.1/tcp/5889"
      echo "Patch systemd units"
      sed -i "s|ExecStart=/usr/local/bin/ipfs|ExecStart=${relative_target}/bin/ipfs|" "${prefix}/etc/systemd/system/ipfs.service"
      if test -z "${prefix}" && has_systemd; then
              echo "Reload systemd"
              systemctl daemon-reload
          fi
      fi

  - name: kustomize
    version: 4.5.7
    check: ${binary} version --short | tr -s ' ' | cut -d' ' -f1 | cut -d/ -f2 | tr -d v
    tags:
    - k8s
    - kubernetes
    - templating
    - management
    download:
    - url: https://github.com/kubernetes-sigs/kustomize/releases/download/kustomize%2Fv${version}/kustomize_v${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/kustomize"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/kustomize.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_kustomize"

  - name: lazydocker
    version: 0.18.1
    check: ${binary} --version | grep Version | cut -d' ' -f2
    needs:
    - docker
    tags:
    - docker
    - management
    - tui
    download:
    - url: https://github.com/jesseduffield/lazydocker/releases/download/v${version}/lazydocker_${version}_Linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - lazydocker

  - name: lazygit
    version: 0.32.2
    check: ${binary} --version | cut -d' ' -f6 | cut -d= -f2 | tr -d ,
    tags:
    - development
    - management
    - tui
    download:
    - url: https://github.com/jesseduffield/lazygit/releases/download/v${version}/lazygit_${version}_Linux_${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - lazygit

  - name: libcap
    version: 2.65
    binary: ${target}/sbin/setcap
    needs:
    - docker
    tags:
    - kernel
    - caps
    dockerfile: |
      FROM ubuntu:latest
      RUN apt-get update \
       && apt-get -y install --no-install-recommends \
              build-essential \
              git \
              ca-certificates
    install: |
      docker_run \
          --workdir /libcap \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "libcap-${version}" https://git.kernel.org/pub/scm/libs/libcap/libcap.git .
      make -C progs
      make -C progs install FAKEROOT=/target
      cp doc/capsh.1 /target/share/man/man1
      cp doc/getcap.8 /target/share/man/man8
      cp doc/getpcaps.8 /target/share/man/man8
      cp doc/setcap.8 /target/share/man/man8
      EOF

  - name: libcap-ng
    version: 0.8.3
    binary: captest
    needs:
    - docker
    tags:
    - kernel
    - caps
    dockerfile: |
      FROM ubuntu:latest
      RUN apt-get update \
       && apt-get -y install --no-install-recommends \
              git \
              curl \
              ca-certificates \
              autoconf \
              automake \
              libtool \
              build-essential
    install: |
      docker_run \
          --workdir /libcap-ng \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/stevegrubb/libcap-ng .
      ./autogen.sh
      ./configure --prefix=/target --enable-static --disable-shared --without-python
      make LDFLAGS=--static
      make install
      EOF

  - name: libcgroup
    version: 2.0.2
    binary: ${target}/bin/lscgroup
    needs:
    - docker
    tags:
    - kernel
    - cgroup
    dockerfile: |
      FROM ubuntu:latest
      RUN apt-get update \
       && apt-get -y install --no-install-recommends \
              build-essential \
              autoconf \
              automake \
              libtool \
              git \
              ca-certificates \
              m4 \
              bison \
              flex \
              curl
    install: |
      docker_run \
          --workdir /libcgroup \
          <<EOF
      curl -sL https://github.com/libcgroup/libcgroup/releases/download/v${version}/libcgroup-${version}.tar.gz \
      | tar -xz --strip-components 1
      ./configure --prefix=/target --disable-pam --disable-daemon
      make
      make install
      EOF
      cat >/etc/ld.so.conf.d/libcgroup.conf <<EOF
      ${target}/lib
      EOF
      ldconfig

  - name: manifest-tool
    version: 2.0.5
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - docker
    - registry
    download:
    - url: https://github.com/estesp/manifest-tool/releases/download/v${version}/binaries-manifest-tool-${version}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - manifest-tool-linux-${alt_arch}
    post_install: |
      mv "${target}/bin/manifest-tool-linux-${alt_arch}" "${target}/bin/manifest-tool"

  - name: minikube
    version: 1.26.1
    check: ${binary} version | grep "minikube version" | cut -d' ' -f3 | tr -d v
    tags:
    - k8s
    - kubernetes
    - management
    download:
    - url: https://github.com/kubernetes/minikube/releases/download/v${version}/minikube-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/minikube"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/minikube.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_minikube"

  - name: mitmproxy
    version: 8.1.1
    tags:
    - network
    download:
    - url:
        x86_64: https://snapshots.mitmproxy.org/${version}/mitmproxy-${version}-linux.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - mitmproxy
      - mitmdump
      - mitmweb

  - name: mutagen
    version: 0.15.0
    check: ${binary} version
    tags:
    - security
    - network
    - storage
    download:
    - url: https://github.com/mutagen-io/mutagen/releases/download/v${version}/mutagen_linux_${alt_arch}_v${version}.tar.gz
      type: tarball
      path: ${target}/bin
    post_install: |
      echo "Install agents"
      mkdir -p "${target}/libexec/mutagen"
      tar -xz \
          --file "${target}/bin/mutagen-agents.tar.gz" \
          --directory "${target}/libexec/mutagen"
      rm "${target}/bin/mutagen-agents.tar.gz"
      echo "Install completion for ${name}"
      ${binary} generate \
          "--bash-completion-script=${target}/share/bash-completion/completions/${name}" \
          "--fish-completion-script=${target}/share/fish/vendor_completions.d/${name}.fish" \
          "--zsh-completion-script=${target}/share/zsh/vendor-completions/_${name}"

  - name: mutagen-compose
    version: 0.14.0-1
    needs:
    - mutagen
    tags:
    - security
    - network
    - storage
    install: |
      curl https://github.com/mutagen-io/mutagen-compose/releases/download/v${version}/mutagen-compose_linux_${alt_arch}_v${version%-*}.tar.gz \
          --silent \
          --location \
      | tar -xz \
          --directory "${target}/bin" \
          --no-same-owner

  - name: nerdctl
    version: 0.22.2
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - containerd
    - rootless
    - management
    download:
    - url: https://github.com/containerd/nerdctl/releases/download/v${version}/nerdctl-${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin

  - name: norouter
    version: 0.6.4
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - network
    download:
    - url: https://github.com/norouter/norouter/releases/download/v${version}/norouter-Linux-${arch}.tgz
      type: tarball
      path: ${target}/bin
      files:
      - norouter

  - name: notation
    version: 0.7.1-alpha.1
    check: ${binary} --version | cut -d' ' -f3
    needs:
    - docker
    tags:
    - docker
    - plugin
    - security
    download:
    - url: https://github.com/notaryproject/notation/releases/download/v${version}/notation_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - notation
    - url: https://github.com/notaryproject/notation/releases/download/v${version}/notation_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/libexec/docker/cli-plugins
      files:
      - docker-generate
      - docker-notation

  - name: nsutils
    version: 0.2
    binary: nslist
    needs:
    - docker
    tags:
    - kernel
    - namespaces
    dockerfile: |
      FROM ubuntu:latest
      RUN apt-get update \
       && apt-get -y install --no-install-recommends \
              git \
              ca-certificates \
              autoconf \
              automake \
              build-essential \
              libcap-dev \
              libbsd-dev \
              libcap2-bin
    install: |
      echo "nsutils ${version}"
      docker_run \
          --workdir /nsutils \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/rd235/nsutils .
      autoreconf -if
      ./configure --prefix=/target
      make LDFLAGS=--static
      mkdir -p \
          /target/share/man/man1
      make install
      EOF

  - name: oci-image-tool
    version: 1.0.0-rc3
    check: ${binary} --version | cut -d' ' -f3
    needs:
    - docker
    tags:
    - oci
    dockerfile: |
      FROM golang:${go_version}
    install: |
      echo "oci-image-tool ${version}"
      docker_run \
          --env GO111MODULE=auto \
          --workdir /go/src/github.com/opencontainers/image-tools \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/opencontainers/image-tools .
      make tool
      cp oci-image-tool /target/bin/
      EOF

  - name: oci-runtime-tool
    version: 0.9.0
    check: ${binary} --version | cut -d, -f1 | cut -d' ' -f3
    needs:
    - docker
    tags:
    - oci
    dockerfile: |
      FROM golang:${go_version}
    install: |
      echo "oci-runtime-tool ${version}"
      docker_run \
          --env GO111MODULE=auto \
          --workdir /go/src/github.com/opencontainers/runtime-tools \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/opencontainers/runtime-tools .
      make tool
      cp oci-runtime-tool /target/bin/
      EOF

  - name: oras
    version: 0.13.0
    check: ${binary} version | head -n 1 | tr -s ' ' | cut -d' ' -f2
    tags:
    - registry
    - storage
    - cnab
    download:
    - url: https://github.com/oras-project/oras/releases/download/v${version}/oras_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - oras

  - name: patat
    version: 0.8.7.0
    tags:
    - markdown
    download:
    - url: https://github.com/jaspervdj/patat/releases/download/v${version}/patat-v${version}-linux-${arch}.tar.gz
      type: tarball
      path: ${target}/bin
      strip: 1
      files:
      - patat-v${version}-linux-${arch}/patat
    - url: https://github.com/jaspervdj/patat/releases/download/v${version}/patat-v${version}-linux-${arch}.tar.gz
      type: tarball
      path: ${target}/share/man/man1
      strip: 1
      files:
      - patat-v${version}-linux-${arch}/patat.1

  - name: podman
    version: 4.1.1
    check: ${binary} --version | cut -d' ' -f3
    needs:
    - conmon
    - runc
    - cni
    tags:
    - runtime
    - redhat
    - oci
    download:
    - url:
        x86_64: https://github.com/nicholasdille/podman-static/releases/download/v${version}/podman.tar.gz
      type: tarball
      path: ${target}

  - name: portainer
    version: 2.14.2
    check: ${binary} --version 2>&1
    needs:
    - docker
    - docker-compose-v1
    tags:
    - docker
    - k8s
    - kubernetes
    - management
    download:
    - url: https://github.com/portainer/portainer/releases/download/${version}/portainer-${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      strip: 1
      files:
      - portainer/portainer
    - url: https://github.com/portainer/portainer/releases/download/${version}/portainer-${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/share/portainer
      strip: 1
      files:
      - portainer/public
    files:
    - path: ${prefix}/etc/systemd/system/portainer.service
      content: |
        [Unit]
        Description=portainer
        Documentation=https://www.portainer.io/
        After=network.target local-fs.target

        [Service]
        ExecStart=/usr/local/bin/portainer --assets=${TARGET}/share/portainer --data=${TARGET}/lib/portainer --bind=127.0.0.1:9000 --bind-https=127.0.0.1:9443 --tunnel-addr=127.0.0.1

        Type=exec
        Delegate=yes
        KillMode=process
        Restart=always
        RestartSec=5
        # Having non-zero Limit*s causes performance problems due to accounting overhead
        # in the kernel. We recommend using cgroups to do container-local accounting.
        LimitNPROC=infinity
        LimitCORE=infinity
        LimitNOFILE=1048576
        # Comment TasksMax if your systemd version does not supports it.
        # Only systemd 226 and above support this version.
        TasksMax=infinity

        [Install]
        WantedBy=multi-user.target
    - path: ${prefix}/etc/init.d/portainer
      content: |
        #!/bin/sh
        set -e

        ### BEGIN INIT INFO
        # Provides:           portainer
        # Required-Start:     $syslog $remote_fs
        # Required-Stop:      $syslog $remote_fs
        # Should-Start:       cgroupfs-mount cgroup-lite
        # Should-Stop:        cgroupfs-mount cgroup-lite
        # Default-Start:      2 3 4 5
        # Default-Stop:       0 1 6
        # Short-Description:  Create lightweight, portable, self-sufficient containers.
        # Description:
        #  Docker is an open-source project to easily create lightweight, portable,
        #  self-sufficient containers from any application. The same container that a
        #  developer builds and tests on a laptop can run at scale, in production, on
        #  VMs, bare metal, OpenStack clusters, public clouds and more.
        ### END INIT INFO

        export PATH=/sbin:/bin:/usr/sbin:/usr/bin:/usr/local/sbin:/usr/local/bin

        BASE=portainer

        # modify these in /etc/default/$BASE (/etc/default/portainer)
        PORTAINER=/usr/local/bin/portainer
        # This is the pid file created/managed by start-stop-daemon
        PORTAINER_SSD_PIDFILE=/var/run/$BASE-ssd.pid
        PORTAINER_LOGFILE=/var/log/$BASE.log
        PORTAINER_DESC="Portainer"

        # Get lsb functions
        . /lib/lsb/init-functions

        if [ -f /etc/default/$BASE ]; then
          . /etc/default/$BASE
        fi

        # Check portainer is present
        if [ ! -x $PORTAINER ]; then
          log_failure_msg "$PORTAINER not present or not executable"
          exit 1
        fi

        check_init() {
          # see also init_is_upstart in /lib/lsb/init-functions (which isn't available in Ubuntu 12.04, or we'd use it directly)
          if [ -x /sbin/initctl ] && /sbin/initctl version 2> /dev/null | grep -q upstart; then
            log_failure_msg "$PORTAINER_DESC is managed via upstart, try using service $BASE $1"
            exit 1
          fi
        }

        fail_unless_root() {
          if [ "$(id -u)" != '0' ]; then
            log_failure_msg "$PORTAINER_DESC must be run as root"
            exit 1
          fi
        }

        cgroupfs_mount() {
          # see also https://github.com/tianon/cgroupfs-mount/blob/master/cgroupfs-mount
          if grep -v '^#' /etc/fstab | grep -q cgroup \
            || [ ! -e /proc/cgroups ] \
            || [ ! -d /sys/fs/cgroup ]; then
            return
          fi
          if ! mountpoint -q /sys/fs/cgroup; then
            mount -t tmpfs -o uid=0,gid=0,mode=0755 cgroup /sys/fs/cgroup
          fi
          (
            cd /sys/fs/cgroup
            for sys in $(awk '!/^#/ { if ($4 == 1) print $1 }' /proc/cgroups); do
              mkdir -p $sys
              if ! mountpoint -q $sys; then
                if ! mount -n -t cgroup -o $sys cgroup $sys; then
                  rmdir $sys || true
                fi
              fi
            done
          )
        }

        case "$1" in
          start)
            check_init

            fail_unless_root

            cgroupfs_mount

            touch "$PORTAINER_LOGFILE"

            ulimit -n 1048576

            # Having non-zero limits causes performance problems due to accounting overhead
            # in the kernel. We recommend using cgroups to do container-local accounting.
            if [ "$BASH" ]; then
              ulimit -u unlimited
            else
              ulimit -p unlimited
            fi

            log_begin_msg "Starting $PORTAINER_DESC: $BASE"
            start-stop-daemon --start --background \
              --no-close \
              --exec "$PORTAINER" \
              --pidfile "$PORTAINER_SSD_PIDFILE" \
              --make-pidfile \
              -- \
              >> "$PORTAINER_LOGFILE" 2>&1
            log_end_msg $?
            ;;

          stop)
            check_init
            fail_unless_root
            if [ -f "$PORTAINER_SSD_PIDFILE" ]; then
              log_begin_msg "Stopping $PORTAINER_DESC: $BASE"
              start-stop-daemon --stop --pidfile "$PORTAINER_SSD_PIDFILE" --retry 10
              log_end_msg $?
            else
              log_warning_msg "Docker already stopped - file $PORTAINER_SSD_PIDFILE not found."
            fi
            ;;

          restart)
            check_init
            fail_unless_root
            portainer_pid=$(cat "$PORTAINER_SSD_PIDFILE" 2> /dev/null)
            [ -n "$portainer_pid" ] \
              && ps -p $portainer_pid > /dev/null 2>&1 \
              && $0 stop
            $0 start
            ;;

          force-reload)
            check_init
            fail_unless_root
            $0 restart
            ;;

          status)
            check_init
            status_of_proc -p "$PORTAINER_SSD_PIDFILE" "$PORTAINER" "$PORTAINER_DESC"
            ;;

          *)
            echo "Usage: service portainer {start|stop|restart|status}"
            exit 1
            ;;
        esac
    post_install: |
      echo "Install dedicated docker-compose v1"
      cp "${target}/bin/docker-compose" "${target}/share/portainer/docker-compose"
      echo "Fix systemd unit"
      sed -i "s|/usr/local/bin/portainer|${relative_target}/bin/portainer|g" "${prefix}/etc/systemd/system/portainer.service"
      echo "Fix init script"
      sed -i "s|/usr/local/bin/portainer|${relative_target}/bin/portainer|g" "${prefix}/etc/init.d/portainer"
      chmod +x "${prefix}/etc/init.d/portainer"
      if test -z "${prefix}"; then
          if has_systemd; then
              echo "Reload systemd"
              systemctl daemon-reload
          fi
      fi

  - name: porter
    version: 0.38.12
    check: ${binary} --version | cut -d' ' -f2 | tr -d v
    tags:
    - cnab
    download:
    - url: https://github.com/getporter/porter/releases/download/v${version}/porter-linux-${alt_arch}
      type: executable
    post_install: |
      if test -z "${prefix}"; then
          echo "Install mixins"
          ${binary} mixin install exec
          ${binary} mixin install docker
          ${binary} mixin install docker-compose
          ${binary} mixin install kubernetes
          echo "Install plugins"
          ${binary} plugins install kubernetes
      fi

  - name: qemu
    version: 7.0.0
    binary: qemu-img
    check: ${binary} --version | grep qemu-img | cut -d' ' -f3
    tags:
    - vm
    - emulation
    download:
    - url: https://github.com/nicholasdille/qemu-static/releases/download/v${version}/qemu-${alt_arch}.tar.gz
      type: tarball
      strip: 2
      path: ${target}

  - name: regclient
    version: 0.4.4
    binary: regctl
    check: ${binary} version | jq -r .VCSTag | tr -d v
    tags:
    - registry
    - management
    download:
    - url: https://github.com/regclient/regclient/releases/download/v${version}/regctl-linux-${alt_arch}
      type: executable
      path: ${target}/bin/regctl
    - url: https://github.com/regclient/regclient/releases/download/v${version}/regbot-linux-${alt_arch}
      type: executable
      path: ${target}/bin/regbot
    - url: https://github.com/regclient/regclient/releases/download/v${version}/regsync-linux-${alt_arch}
      type: executable
      path: ${target}/bin/regsync
    post_install: |
      echo "Install completion for regctl"
      ${binary} completion bash >"${target}/share/bash-completion/completions/regctl"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/regctl.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_regctl"
      echo "Install completion for regbot"
      "${target}/bin/regbot" completion bash >"${target}/share/bash-completion/completions/regbot"
      "${target}/bin/regbot" completion fish >"${target}/share/fish/vendor_completions.d/regbot.fish"
      "${target}/bin/regbot" completion zsh >"${target}/share/zsh/vendor-completions/_regbot"
      echo "Install completion for regsync"
      "${target}/bin/regsync" completion bash >"${target}/share/bash-completion/completions/regsync"
      "${target}/bin/regsync" completion fish >"${target}/share/fish/vendor_completions.d/regsync.fish"
      "${target}/bin/regsync" completion zsh >"${target}/share/zsh/vendor-completions/_regsync"

  - name: rootlesskit
    version: 1.0.1
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - rootless
    download:
    - url: https://github.com/rootless-containers/rootlesskit/releases/download/v${version}/rootlesskit-${arch}.tar.gz
      type: tarball
      path: ${target}/bin

  - name: runc
    version: 1.1.3
    check: ${binary} --version | head -n 1 | cut -d' ' -f3
    tags:
    - runtime
    - oci
    download:
    - url: https://github.com/opencontainers/runc/releases/download/v${version}/runc.${alt_arch}
      type: executable
    dockerfile: |
      FROM golang:${go_version}
    post_install: |
      if ${skip_docs}; then
          warning "Installation of manpages will be skipped."

      else
          docker_run \
              --volume "${target}/share/man:/opt/man" \
              --workdir /go/src/github.com/opencontainers/runc \
              <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/opencontainers/runc .
      go install github.com/cpuguy83/go-md2man@latest
      man/md2man-all.sh -q
      cp -r man/man8/ "/opt/man"
      EOF
      fi

  - name: scorecard
    version: 4.5.0
    check: ${binary} version | grep "GitVersion" | cut -dv -f2
    tags:
    - security
    download:
    - url: https://github.com/ossf/scorecard/releases/download/v${version}/scorecard_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - scorecard-linux-${alt-arch}
    post_install: |
      echo "Rename binary"
      mv "${target}/bin/scorecard-linux-${alt_arch}" "${target}/bin/scorecard"
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/scorecard"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/scorecard.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_scorecard"

  - name: skopeo
    version: 1.9.2
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - registry
    - redhat
    - oci
    download:
    - url:
        x86_64: https://github.com/nicholasdille/skopeo-static/releases/download/v${version}/skopeo.tar.gz
      type: tarball
      path: ${target}

  - name: slirp4netns
    version: 1.2.0
    check: ${binary} --version | head -n 1 | cut -d' ' -f3
    tags:
    - rootless
    - network
    download:
    - url: https://github.com/rootless-containers/slirp4netns/releases/download/v${version}/slirp4netns-${arch}
      type: executable
    dockerfile: |
      FROM golang:${go_version}
    post_install: |
      if ${skip_docs}; then
          warning "Installation of manpages will be skipped."

      else
          docker_run \
              --volume "${target}/share/man:/opt/man" \
              --workdir /go/src/github.com/rootless-containers/slirp4netns \
              <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/rootless-containers/slirp4netns .
      cp *.1 /opt/man/man1
      EOF
      fi

  - name: sops
    version: 3.7.3
    check: ${binary} --version | head -n 1 | cut -d' ' -f2
    tags:
    - security
    download:
    - url:
        x86_64: https://github.com/mozilla/sops/releases/download/v${version}/sops-v${version}.linux
      type: executable

  - name: sshocker
    version: 0.3.0
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    tags:
    - security
    - network
    - storage
    download:
    - url: https://github.com/lima-vm/sshocker/releases/download/v${version}/sshocker-Linux-${arch}
      type: executable

  - name: stargz-snapshotter
    version: 0.12.0
    binary: containerd-stargz-grpc
    check: ${binary} -version | cut -d' ' -f2 | tr -d v
    needs:
    - containerd
    tags:
    - containerd
    - storage
    download:
    - url: https://github.com/containerd/stargz-snapshotter/releases/download/v${version}/stargz-snapshotter-v${version}-linux-${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
    files:
    - path: contrib/${tool}/stargz-snapshotter.service
      content: |
        [Unit]
        Description=stargz snapshotter
        PartOf=containerd

        [Service]
        Environment=IPFS_PATH=${XDG_DATA_HOME}/ipfs
        ExecStart=/usr/local/bin/containerd-stargz-grpc -address "${XDG_RUNTIME_DIR}/containerd-stargz-grpc/containerd-stargz-grpc.sock" -root "${XDG_DATA_HOME}/containerd-stargz-grpc" -config "${XDG_CONFIG_HOME}/containerd-stargz-grpc/config.toml"
        ExecReload=/bin/kill -s HUP \$MAINPID
        RestartSec=2
        Restart=always
        Type=simple
        KillMode=mixed

        [Install]
        WantedBy=default.target
    post_install: |
      echo "Add configuration to containerd"
      cat >"${docker_setup_cache}/containerd-config.toml-stargz-snapshotter.sh" <<EOF
      "${target}/bin/dasel" put object --file "${prefix}/etc/containerd/config.toml" --parser toml --type string --type string proxy_plugins."stargz" type=snapshot address=/var/run/containerd-stargz-grpc.sock
      EOF
      echo "Install systemd units"
      cp "${docker_setup_contrib}/${tool}/stargz-snapshotter.service" "${prefix}/etc/systemd/system/stargz-snapshotter.service"
      sed -i "s|ExecStart=/usr/local/bin/containerd-stargz-grpc|ExecStart=${relative_target}/bin/containerd-stargz-grpc|" "${prefix}/etc/systemd/system/stargz-snapshotter.service"
      if test -z "${prefix}"; then
          if has_systemd; then
              echo "Reload systemd"
              systemctl daemon-reload
          fi
      fi

  - name: syft
    version: 0.53.4
    check: ${binary} --version | cut -d' ' -f2
    tags:
    - sbom
    - security
    download:
    - url: https://github.com/anchore/syft/releases/download/v${version}/syft_${version}_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - syft
    post_install: |
      echo "Install completion"
      ${binary} completion bash | sed -E 's/^(\s*complete.*)/\1 syft/'            >"${target}/share/bash-completion/completions/syft"
      ${binary} completion fish | sed -E 's/complete -c  -e/complete -c syft -e/' >"${target}/share/fish/vendor_completions.d/syft.fish"
      ${binary} completion zsh                                                    >"${target}/share/zsh/vendor-completions/_syft"

  - name: task
    version: 3.14.1
    check: ${binary} --version | cut -d' ' -f3 | tr -d v
    tags:
    - development
    download:
    - url: https://github.com/go-task/task/releases/download/v${version}/task_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - task
    - url: https://github.com/go-task/task/releases/download/v${version}/task_linux_${alt_arch}.tar.gz
      type: tarball
      path: ${target}/share
      strip: 2
      files:
      - completion/bash/task.bash
      - completion/fish/task.fish
      - completion/zsh/_task
    post_install: |
      mv "${target}/share/task.bash" "${target}/share/bash-completion/completions/task"
      mv "${target}/share/task.fish" "${target}/share/fish/vendor_completions.d/task.fish"
      mv "${target}/share/_task" "${target}/share/zsh/vendor-completions/_task"

  - name: trivy
    version: 0.30.4
    check: ${binary} --version | cut -d' ' -f2
    tags:
    - security
    - analysis
    download:
    - url:
        x86_64: https://github.com/aquasecurity/trivy/releases/download/v${version}/trivy_${version}_Linux-64bit.tar.gz
        aarch64: https://github.com/aquasecurity/trivy/releases/download/v${version}/trivy_${version}_Linux-ARM64.tar.gz
      type: tarball
      path: ${target}/bin
      files:
      - trivy

  - name: uidmap
    version: 4.11.1
    binary: newuidmap
    needs:
    - docker
    tags:
    - kernel
    dockerfile: |
      FROM ubuntu:latest
      RUN apt-get update \
       && apt-get -y install --no-install-recommends \
              curl \
              ca-certificates \
              xz-utils \
              build-essential
    install: |
      docker_run \
          --env DEBIAN_FRONTEND=noninteractive \
          --workdir /uidmap \
          <<EOF
      curl -sL https://github.com/shadow-maint/shadow/releases/download/v${version}/shadow-${version}.tar.xz \
      | tar -xJ --strip-components 1
      ./configure --prefix=/target --enable-static --disable-shared
      make LDFLAGS=--static
      mkdir -p \
          /target/bin \
          /target/share/man/man1
      cp src/newuidmap /target/bin
      cp src/newgidmap /target/bin
      cp man/man1/newuidmap.1 /target/share/man/man1
      cp man/man1/newgidmap.1 /target/share/man/man1
      EOF

  - name: umoci
    version: 0.4.7
    check: ${binary} --version | cut -d' ' -f3
    tags:
    - oci
    download:
    - url: https://github.com/opencontainers/umoci/releases/download/v${version}/umoci.${alt_arch}
      type: executable

  - name: util-linux
    version: 2.38.1
    binary: lsns
    needs:
    - docker
    tags:
    - kernel
    - namespaces
    dockerfile: |
      FROM ubuntu:latest
      ENV DEBIAN_FRONTEND=noninteractive
      RUN apt-get update \
       && apt-get -y install --no-install-recommends \
              git \
              ca-certificates \
              autoconf \
              automake \
              autopoint \
              gettext \
              bison \
              libtool \
              pkg-config \
              make \
              asciidoctor
    install: |
      docker_run \
          --workdir /util-linux \
          <<EOF
      git clone -q --config advice.detachedHead=false --depth 1 --branch "v${version}" https://github.com/util-linux/util-linux .
      ./autogen.sh
      ./configure --disable-shared
      make LDFLAGS=--static
      mkdir -p \
          /target/bin \
          /target/share/man/man1 \
          /target/share/man/man8 \
          /target/share/bash-completion/completions
      cp lsns nsenter unshare /target/bin
      cp \
          sys-utils/nsenter.1 sys-utils/unshare.1 \
          /target/share/man/man1/
      cp sys-utils/lsns.8 /target/share/man/man8/
      cp \
          bash-completion/lsns bash-completion/nsenter bash-completion/unshare \
          /target/share/bash-completion/completions
      EOF

  - name: vendir
    version: 0.30.0
    check: ${binary} version | head -n 1 | cut -d' ' -f3
    tags:
    - development
    download:
    - url: https://github.com/vmware-tanzu/carvel-vendir/releases/download/v${version}/vendir-linux-${arch}
      type: executable

  - name: ytt
    version: 0.42.0
    check: ${binary} version | cut -d' ' -f3
    tags:
    - k8s
    - kubernetes
    - templating
    - package
    - manager
    download:
    - url: https://github.com/vmware-tanzu/carvel-ytt/releases/download/v${version}/ytt-linux-${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} completion bash >"${target}/share/bash-completion/completions/ytt"
      ${binary} completion fish >"${target}/share/fish/vendor_completions.d/ytt.fish"
      ${binary} completion zsh >"${target}/share/zsh/vendor-completions/_ytt"

  - name: yq
    version: 4.27.2
    check: ${binary} --version | cut -d' ' -f4
    tags:
    - conversion
    - format
    download:
    - url: https://github.com/mikefarah/yq/releases/download/v${version}/yq_linux_${alt_arch}
      type: executable
    post_install: |
      echo "Install completion"
      ${binary} shell-completion bash >"${target}/share/bash-completion/completions/yq"
      ${binary} shell-completion fish >"${target}/share/fish/vendor_completions.d/yq.fish"
      ${binary} shell-completion zsh >"${target}/share/zsh/vendor-completions/_yq"
