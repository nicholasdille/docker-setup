#!/bin/bash
set -o errexit

: "${docker_setup_version:=main}"

function show_banner() {
    cat <<"EOF"
     _            _                           _
  __| | ___   ___| | _____ _ __      ___  ___| |_ _   _ _ __
 / _` |/ _ \ / __| |/ / _ \ '__|____/ __|/ _ \ __| | | | '_ \
| (_| | (_) | (__|   <  __/ | |_____\__ \  __/ |_| |_| | |_) |
 \__,_|\___/ \___|_|\_\___|_|       |___/\___|\__|\__,_| .__/
                                                       |_|
                     The container tools installer and updater
                 https://github.com/nicholasdille/docker-setup
--------------------------------------------------------------
This script will install Docker Engine as well as useful tools
from the container ecosystem.

EOF
}

# https://unicode.org/emoji/charts-14.0/full-emoji-list.html
emoji_tool="$(echo -e "\U0001F528")"
emoji_auth="$(echo -e "\U0001F513")"
emoji_whale="$(echo -e "\U0001F433")"
emoji_container=$(echo -e "\U0001F5C3")
emoji_image="$(echo -e "\U0001F4E6")"
emoji_layer="$(echo -e "\U0001F4C2")"
emoji_archive="$(echo -e "\U0001F4E5")"
emoji_sign="$(echo -e "\U00002712")"
emoji_push="$(echo -e "\U0001F4E4")"
emoji_pull="$(echo -e "\U0001F4E5")"
emoji_build="$(echo -e "\U0001F9F1")"
emoji_inspect="$(echo -e "\U0001F50D")"

: "${REGISTRY:=ghcr.io}"
: "${REPOSITORY_PREFIX:=nicholasdille/docker-setup/}"

: "${docker_setup_cache:=/var/cache/docker-setup}"
if ! test -w "${docker_setup_cache}"; then
    >&2 echo "WARNING: Cache directory <${docker_setup_cache}> is not writable."
    docker_setup_cache="${HOME}/.cache/docker-setup"
    >&2 echo "WARNING: Using cache directory <${docker_setup_cache}>"
fi
mkdir -p "${docker_setup_cache}"

export PATH="${docker_setup_cache}/bin:${PATH}"
REGCLIENT_VERSION=0.4.4
if ! type regctl >/dev/null 2>&1 || test "$(regctl version | jq -r .VCSTag | tr -d v)" != "${REGCLIENT_VERSION}"; then
    >&2 echo "Installing regctl"
    mkdir -p "${docker_setup_cache}/bin"
    curl --silent --location --output "${docker_setup_cache}/bin/regctl" \
        "https://github.com/regclient/regclient/releases/download/v${REGCLIENT_VERSION}/regctl-linux-amd64"
    chmod +x "${docker_setup_cache}/bin/regctl"
fi
YQ_VERSION=4.27.5
if ! type yq >/dev/null 2>&1 || test "$(yq --version | cut -d' ' -f4)" != "${YQ_VERSION}"; then
    >&2 echo "Installing yq"
    mkdir -p "${docker_setup_cache}/bin"
    curl --silent --location --output "${docker_setup_cache}/bin/yq" \
        "https://github.com/mikefarah/yq/releases/download/v${YQ_VERSION}/yq_linux_amd64"
    chmod +x "${docker_setup_cache}/bin/yq"
fi
JQ_VERSION=1.6
if ! type jq >/dev/null 2>&1 || test "$(jq --version | cut -d- -f2)" != "${JQ_VERSION}"; then
    >&2 echo "Installing jq"
    mkdir -p "${docker_setup_cache}/bin"
    curl --silent --location --output "${docker_setup_cache}/bin/yq" \
        "https://github.com/stedolan/jq/releases/download/jq-${JQ_VERSION}/jq-linux64"
    chmod +x "${docker_setup_cache}/bin/jq"
fi

if test -z "${DOCKER_CONFIG}"; then
    export DOCKER_CONFIG="${HOME}/.docker"
fi

if ! regctl registry config | jq --exit-status --arg registry "${REGISTRY}" 'to_entries[] | select(.key == $registry)' >/dev/null 2>&1; then
    >&2 echo "WARNING: regctl does not know how to login to ${REGISTRY}"

    if test -f "${DOCKER_CONFIG}/config.json" && jq --exit-status --arg registry ghcr.io '.auths | to_entries[] | select(.key == $registry)' "${DOCKER_CONFIG}/config.json" >/dev/null; then
        >&2 echo "${emoji_auth} Logging in to ${REGISTRY} using credentials from Docker config.json"
        AUTH="$(jq -r '.auths | to_entries[] | select(.key == "ghcr.io") | .value.auth' "${DOCKER_CONFIG}/config.json" | base64 -d)"
        regctl registry login ${REGISTRY} --user "${AUTH%%:*}" --pass "${AUTH#*:}"

    elif test -n "${REGISTRY_USERNAME}" && test -n "${REGISTRY_PASSWORD}"; then
        >&2 echo "${emoji_Auth} Logging in to ${REGISTRY} using credentials from environment variables"
        regctl registry login ${REGISTRY} --user "${REGISTRY_USERNAME}" --pass "${REGISTRY_PASSWORD}"

    elif ! test -t 1; then
        >&2 echo "${emoji_auth} No console available. Unable to login to ${REGISTRY}."

    else
        echo "${emoji_auth} Logging in to ${REGISTRY}"
        regctl registry login ${REGISTRY}
    fi
fi

docker_setup_tools_file="${docker_setup_cache}/tools.json"
if test -f "${PWD}/tools.json"; then
    docker_setup_tools_file="${PWD}/tools.json"
fi
>&2 echo "Using ${docker_setup_tools_file}"
if ! test -f "${docker_setup_tools_file}"; then
    regctl manifest get "${REGISTRY}/${REPOSITORY_PREFIX}metadata:${docker_setup_version}" --format raw-body | jq --raw-output '.layers[].digest' \
    | while read DIGEST; do
        regctl blob get "${REGISTRY}/${REPOSITORY_PREFIX}metadata:${docker_setup_version}" "${DIGEST}" \
        | tar --extract --gzip --directory="${docker_setup_cache}" --no-same-owner
    done
fi

docker_setup_dockerfile_template="${docker_setup_cache}/Dockerfile.template"
if test -f "${PWD}/Dockerfile.template"; then
    docker_setup_dockerfile_template="${PWD}/Dockerfile.template"
fi
curl --silent --location --output "${docker_setup_dockerfile_template}" \
    https://raw.githubusercontent.com/nicholasdille/docker-setup/${docker_setup_version}/tools/Dockerfile.template
>&2 echo "Using ${docker_setup_dockerfile_template}"

declare -A tools_install
declare -a tools_ordered
all_tools="$(
    jq --raw-output '.tools[].name' "${docker_setup_tools_file}" \
    | xargs echo
)"

function resolve_dependencies() {
    local name=$1

    if test -z "${tools_install[${name}]}"; then
        local tool_deps
        tool_deps="$(
            jq --raw-output --arg name "${name}" '.tools[] | select(.name == $name) | select(.dependencies != null) | .dependencies[]' "${docker_setup_tools_file}" \
            | xargs echo
        )"

        local dep
        for dep in ${tool_deps}; do
            if test -z "${tools_install[${dep}]}"; then
                resolve_dependencies "${dep}"
            fi
        done

        tools_ordered+=( "${name}" )
        tools_install["${name}"]=true
    fi
}

function generate() {
    CONTENT="$(
        cat "${docker_setup_dockerfile_template}" \
        | sed -E "s|^ARG ref=main|ARG ref=${docker_setup_version}|"
    )"
    while test "$#" -gt 0; do
        tool=$1
        shift

        CONTENT="$(
            echo "${CONTENT}" \
            | sed -E "s|^(# INSERT FROM)|FROM ${REGISTRY}/${REPOSITORY_PREFIX}${tool}:\${ref} AS ${tool}\n\1|" \
            | sed -E "s|^(# INSERT COPY)|COPY --link --from=${tool} / /\n\1|"
        )"
    done
    echo "${CONTENT}"
}

function show_help() {
    cat <<EOF
docker-setup

Commands:
  ls                      List available tools
  info                    Show tool manifest
  tags                    Show tags
  dependencies            Resolve dependencies
  inspect                 Show contents image
  generate                Generate Dockerfile
  build                   Build container image
  build-flat              Build container image using "docker commit"
  install                 Install natively
  install-from-registry   Install 
  install-from-image      Build container image with local output

Global options:
  --help                  Display help
  --version               Display version
EOF
}

command=$1
shift
case "${command}" in
    --version)
        echo "docker-setup version ${docker_setup_version}"
        ;;

    --help)
        show_help
        ;;
        
    ls)
        show_banner
        jq --raw-output '.tools[] | "\(.name);\(.version);\(.description)"' "${docker_setup_tools_file}" \
        | column --separator ';' --table --table-columns Name,Version,Description --table-truncate 3
        ;;

    info)
        show_banner
        tool=$1
        if test -z "${tool}"; then
            echo "No tool name specified"
            exit 1
        fi
        shift
        jq --raw-output --arg name "${tool}" '.tools[] | select(.name == $name)' "${docker_setup_tools_file}" \
        | yq --prettyPrint
        echo
        ;;

    tags)
        show_banner
        jq -r '.tools[].tags[]' "${docker_setup_tools_file}" | sort | uniq | xargs echo
        ;;

    dependencies)
        for name in "$@"; do
            if ! jq --exit-status --arg name "${name}" '.tools[] | select(.name == $name)' "${docker_setup_tools_file}" >/dev/null; then
                >&2 echo "ERROR: Tool <${name}> is unknown."
                exit 1
            fi
            resolve_dependencies "${name}"
        done
        echo "${tools_ordered[@]}"
        ;;

    inspect)
        show_banner
        tool=$1
        if test -z "${tool}"; then
            echo "No tool name specified"
            exit 1
        fi
        shift
        echo "${emoji_tool} Processing ${tool}"
            regctl manifest get "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" --format raw-body | jq --raw-output '.layers[].digest' \
            | while read DIGEST; do
                echo "${emoji_archive} Inspecting ${DIGEST}"
                regctl blob get "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" "${DIGEST}" \
                | tar --list --gzip \
                | grep -v "/$"
            done
        ;;

    generate)
        if test "$#" -eq 0; then
            set -- ${all_tools}
        fi
        for name in "$@"; do
            resolve_dependencies "${name}"
        done
        generate "${tools_ordered[@]}"
        ;;

    build)
        show_banner
        image=$1
        if test -z "${image}"; then
            echo "No image name specified"
            exit 1
        fi
        shift
        if test "$#" -eq 0; then
            set -- ${all_tools}
        fi
        for name in "$@"; do
            resolve_dependencies "${name}"
        done
        generate "${tools_ordered[@]}" \
        | docker build --tag "${image}" -
        ;;

    install)
        show_banner
        target=$1
        if test -z "${target}"; then
            echo "No target specified"
            exit 1
        fi
        shift
        echo "Using target ${target}"
        if test "$#" == 0; then
            echo "No tools specified"
            exit 1
        fi
        mkdir -p "${target}"
        for name in "$@"; do
            resolve_dependencies "${name}"
        done
        for tool in "${tools_ordered[@]}"; do
            echo "${emoji_tool} Processing ${tool}"
            regctl manifest get "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" --format raw-body | jq --raw-output '.layers[].digest' \
            | while read DIGEST; do
                echo "${emoji_archive} Unpacking ${DIGEST}"
                regctl blob get "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" "${DIGEST}" \
                | tar --extract --gzip --directory=${target} --no-same-owner
            done
        done
        ;;

    install-from-registry)
        show_banner
        if ! type docker >/dev/null 2>&1; then
            echo "ERROR: Command <install> requires docker."
            exit 1
        fi
        target=$1
        if test -z "${target}"; then
            echo "No target specified"
            exit 1
        fi
        shift
        echo "Using target ${target}"
        if test "$#" == 0; then
            echo "No tools specified"
            exit 1
        fi
        mkdir -p "${target}"
        for name in "$@"; do
            resolve_dependencies "${name}"
        done
        generate "${tools_ordered[@]}" \
        | docker build --output "${target}" -
        ;;

    install-from-image)
        show_banner
        if ! type docker >/dev/null 2>&1; then
            echo "ERROR: Command <install> requires docker."
            exit 1
        fi
        target=$1
        if test -z "${target}"; then
            echo "No target specified"
            exit 1
        fi
        shift
        echo "Using target ${target}"
        if test "$#" == 0; then
            echo "No tools specified"
            exit 1
        fi
        for name in "$@"; do
            resolve_dependencies "${name}"
        done
        for tool in "${tools_ordered[@]}"; do
            echo "${emoji_tool} Processing ${tool}"
            echo "${emoji_image} Pulling image ${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}"
            docker image pull --quiet "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}"
            echo "${emoji_layer} Reading layers"
            docker image save "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" \
            | tar --extract --to-stdout manifest.json \
            | jq --raw-output '.[].Layers[]' \
            | while read FILE; do
                echo "${emoji_archive} Extracting layer $(dirname "${FILE}")"
                docker image save "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" \
                | tar --extract --to-stdout "${FILE}" \
                | tar --extract --directory="${target}" --strip-components=2
            done
            echo "+ Done"
        done
        ;;
    
    build-flat)
        show_banner
        if ! type docker >/dev/null 2>&1; then
            echo "ERROR: Command <install> requires docker."
            exit 1
        fi
        base=$1
        if test -z "${base}"; then
            echo "No base image name specified"
            exit 1
        fi
        shift
        image=$1
        if test -z "${image}"; then
            echo "No target image name specified"
            exit 1
        fi
        shift
        if test "$#" -eq 0; then
            set -- ${all_tools}
        fi
        for name in "$@"; do
            resolve_dependencies "${name}"
        done
        docker create --name docker-setup-install-flat ${base}
        for tool in "${tools_ordered[@]}"; do
            echo "${emoji_tool} Processing ${tool}"
            regctl manifest get "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" --format raw-body | jq --raw-output '.layers[].digest' \
            | while read DIGEST; do
                echo "${emoji_archive} Unpacking ${DIGEST}"
                regctl blob get "${REGISTRY}/${REPOSITORY_PREFIX}${tool}:${docker_setup_version}" "${DIGEST}" \
                | gunzip \
                | docker cp - docker-setup-install-flat:/
            done
        done
        echo "${emoji_whale} Creating image ${image}"
        docker commit docker-setup-install-flat ${image}
        docker rm docker-setup-install-flat >/dev/null 2>&1
        ;;

    *)
        echo "ERROR: Unknown or empty command <${command}>"
        show_help
        exit 1
        ;;
esac